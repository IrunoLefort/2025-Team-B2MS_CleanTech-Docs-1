<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="stylesheet" href="style-commun.css" />
  <link rel="stylesheet" href="style-code.css" />
  <title>D√©partement √âlectronique</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>D√©partement √âlectronique</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href="index.html" class="nav-link"><i class="fas fa-home"></i> Accueil</a>
        <a href="it.html" class="nav-link"><i class="fas fa-desktop"></i> IT</a>
        
        <div class="nav-section">
         <button class="tab-button active" data-target="electronique-content"><i class="fas fa-microchip"></i> √âlectronique</button>
          <div class="sub-links">
            <a class="subtab-button active" data-target="test1" href="#projet1">Projet 1</a>

            <nav class="project-subnav active" id="subnav-test1">
              <a href="#1-test1">1. Contexte et objectifs</a>
              <a href="#2-test1">2. Choix du capteur</a>
              <a href="#3-test1">3. Principe de fonctionnement</a>
              <a href="#4-test1">4. Sch√©ma √©lectronique sous KICAD</a>
              <a href="#5-test1">5. Codage</a>
              <a href="#6-test1">6. Conception et d√©monstration</a>
              <a href="#7-test1">7. Remarques</a>
              <a href="#8-test1">8. Conclusion</a>
            </nav>

            <a class="subtab-button" data-target="test2" href="#projet2">Projet 2</a>
            <nav class="project-subnav" id="subnav-test2">
              <a href="#1-test2">1. Introduction</a>
              <a href="#2-test2">2. Cahier des charges</a>
              <a href="#3-test2">3. Sch√©ma synoptique</a>
              <a href="#4-test2">4. Description fonctionnelle</a>
              <a href="#5-test2">5. Etapes de validation</a>
              <a href="#6-test2">6. R√©alisation du PCB</a>
              <a href="#7-test2">7. Prototype</a>
            </nav>

            <a class="subtab-button" data-target="test3" href="#projet3">Projet 3</a>
            <nav class="project-subnav" id="subnav-test3">
              <a href="#1-test3">1. Objectifs</a>
              <a href="#2-test3">2. Cahier des charges</a>
              <a href="#3-test3">3. Architecture G√©n√©rale</a>
              <a href="#4-test3">4. Fonctionnement global</a>
              <a href="#5-test3">5. Fonctionnement du Servomoteur</a>
              <a href="#6-test3">6. Utilisation de Servomoteurs</a>
              <a href="#7-test3">7. Biblioth√®que n√©cessaire</a>
              <a href="#8-test3">8. Code</a>
              <a href="#9-test3">9. Test et D√©monstration</a>
              <a href="#10-test3">10. Realisation du PCB</a>
            </nav>
          </div>
        </div>

        <a href="mecanique.html" class="nav-link"><i class="fas fa-cogs"></i> M√©canique</a>
        <a href="convoyeur.html" class="nav-link"></i><i class="fas fa-robot"></i> Convoyeur</a>
      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section id="it-content" class="tab-content active">

        <div id="test1" class="subtab-content active">
          <h2 id="projet1" class="projet-titre">Projet 1 - Gyroscope et Acc√©l√©rom√®tre MPU6050</h2>

          <h3 id="1-test1">1. Contexte et objectifs:</h3>
          <p>
            Les donn√©es de navigation telles que la direction et l'acc√©l√©ration sont essentielles dans la conception d‚Äôun robot.
            Ce projet utilise un module MPU6050, combinant un gyroscope et un acc√©l√©rom√®tre, pour mesurer l‚Äôorientation et les mouvements.
          </p>
          <p>
            Ce projet a pour objectif de :
          </p>
          <ul>
            <li>Comprendre le fonctionnement d‚Äôun capteur inertiel (IMU).</li>
            <li>afficher en temps r√©el les directions (haut, bas, gauche, droite) ainsi que les donn√©es d‚Äôacc√©l√©ration sur un √©cran LCD.</li>
            <li>Utiliser le protocole de communication I2C.</li>
            <li>Appliquer les bonnes pratiques de conception logicielle (structure modulaire, classes bien d√©finies, etc.).</li>
          </ul>

          <h3 id="2-test1">2. Choix du capteur : MPU6050</h3>

          <p>
           Le <strong>MPU6050</strong> est un capteur IMU (Inertial Measurement Unit) 6 axes qui combine :
            <ul>
            <li>Un acc√©l√©rom√®tre 3 axes</li>
            <li>Un gyroscope 3 axes</li>
            </ul>
          </p>
        
          <p>
            Il utilise une interface I2C, parfaitement compatible avec les
            microcontr√¥leurs comme l‚ÄôArduino, ce qui facilite la lecture des
            donn√©es avec un minimum de fils et une consommation r√©duite.
          </p>

          <p>
            Il est largement utilis√© dans la communaut√© Arduino, avec de
            nombreuses biblioth√®ques disponibles (comme MPU6050.h ou
            Wire.h), ce qui simplifie le d√©veloppement et le d√©bogage
          </p>

          <p>
          <strong>Caract√©ristiques principales</strong> : <a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" download class="download-link">datasheet du MPU6050</a>
            <ul>
            <li>Interface I2C (adresse par d√©faut : `0x68`)</li>
            <li>Plage de mesure acc√©l√©rom√®tre : ¬±2g, ¬±4g, ¬±8g, ¬±16g</li>
            <li>Tension d‚Äôalimentation : 3.3V ‚Äì 5V</li>
            </ul>
            
          </p>
          

        <h3 id="3-test1">3. Principe de fonctionnement</h3>
            <p>
             Le capteur MPU6050 combine deux fonctions principales : un acc√©l√©rom√®tre et un gyroscope.
            L‚Äôacc√©l√©rom√®tre permet de mesurer l‚Äôacc√©l√©ration lin√©aire sur les trois axes (X, Y, Z), ce qui
            permet de d√©tecter les mouvements de la main vers le haut, le bas, la gauche, la droite, l‚Äôavant
            ou l‚Äôarri√®re. De son c√¥t√©, le gyroscope mesure la vitesse angulaire sur ces m√™mes axes, ce qui
            permet de conna√Ætre l‚Äôorientation de la main, comme une inclinaison ou une rotation.
          </p>

          <p>
           Pour transmettre les donn√©es au microcontr√¥leur, le MPU6050 utilise le protocole de
            communication I2C. Ce protocole est simple et efficace, car il ne n√©cessite que deux fils : la
            ligne SCL (pour l‚Äôhorloge) et la ligne SDA (pour les donn√©es). Gr√¢ce √† cette liaison, le
            microcontr√¥leur peut envoyer des commandes au capteur et lire ses valeurs en temps r√©el.
          </p>

          <p>
           Pour que le MPU6050 envoie les donn√©es, il ne suffit pas
          de simplement le connecter. √âtant donn√© qu‚Äôon utilise
          une communication I2C, il faut suivre un protocole bien
          d√©fini :
          </p>

          <h4>a. Envoi d‚Äôune commande au capteur</h4>
  
            <p>
            Avant de lire une donn√©e, l‚ÄôArduino doit envoyer l‚Äôadresse du registre souhait√©. Cette adresse indique quel type de
              donn√©e on veut (acc√©l√©ration, vitesse angulaire)
            </p>

            <div class="image-container">
              <img src="images/Test1/Electronique/registre_electronique1.png" alt="Registre" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="images/Test1/Electronique/registre_electronique2.png" alt="Registre" class="image-centree" />
            </div>

          <h4>b. Structure des donn√©es re√ßues</h4>

            <p>
              Chaque mesure (acc√©l√©ration ou rotation) est cod√©e sur 16 bits (2 octets) :  
            </p>
              <ul>
              <li>8 bits MSB (poids fort)</li>
              <li>8 bits LSB (poids faible)</li>
            </ul> 
            <p>
              Les valeurs sont en compl√©ment √† deux (signed integer), ce qui permet d'indiquer un sens positif ou n√©gatif du mouvement. 
            </p>

          <h4>c. Conversion des donn√©es brutes</h4>
  
            <p>
            Pour exploiter les mesures, il faut les convertir en unit√©s physiques :
            </p>
            <ul>
              <li> Acc√©l√©ration en g (gravit√© terrestre)</li>
              <li> Rotation en ¬∞/s (degr√©s par seconde)</li>
            </ul> 

            <div class="image-container">
              <img src="images/Test1/Electronique/converesion_electro1.png" alt="Conversion" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="images/Test1/Electronique/converesion_electro2.png" alt="Conversion" class="image-centree" />
            </div>

          
          <h3 id="4-test1">4. Sch√©ma √©lectronique sous KICAD</h3>
          <div class="image-container">
            <img src="images/Test1/Electronique/schema_electro.png" alt="Sch√©ma √©lectronique sous KICAD" class="image-centree" />
          </div>

          <h3 id="5-test1">5. Codage</h3> 
          <h4>a. Code 1: </h4> 
            <p>
              Ce code utilise la librairie MPU6050 sur Arduino IDE.
            </p>
  
            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code_mpu1-ino', this)">üìã</button>
                <button onclick="telechargerCode('code_mpu1-ino', 'code_mpu1.ino', 'text/ino', this)">ü°á</button>
              </div>
              <pre><code id="code_mpu1-ino">
    #include &lt;Wire.h&gt;               // Biblioth√®que pour communication I2C
    #include &lt;LiquidCrystal_I2C.h&gt;  // Biblioth√®que pour √©cran LCD I2C
    #include &lt;MPU6050.h&gt;            // Biblioth√®que pour capteur MPU6050

    // Initialisation √©cran LCD avec adresse I2C 0x27, 16 colonnes et 2 lignes
    LiquidCrystal_I2C lcd(0x27, 16, 2);

    // Cr√©ation instance MPU6050
    MPU6050 mpu;

    // Variables pour stocker l'acc√©l√©ration en g (gravit√©)
    float ax, ay, az;

    // Norme totale de l'acc√©l√©ration (valeur absolue)
    float accel_norm;

    // Seuil d'acc√©l√©ration (en g) pour d√©tecter un mouvement significatif
    const float threshold = 0.2;

    void setup() {
      Serial.begin(9600);  // Initialisation communication s√©rie √† 9600 bauds (pour debug √©ventuel)
      Wire.begin();        // Initialisation bus I2C

      lcd.init();          // Initialisation √©cran LCD
      lcd.backlight();     // Allumer r√©tro√©clairage LCD

      // Initialisation MPU6050
      mpu.initialize();

      // V√©rification de la connexion avec MPU6050
      if (!mpu.testConnection()) {
        lcd.print("MPU6050 error"); // Affiche erreur si capteur non d√©tect√©
        while (1);                  // Bloque le programme ici (boucle infinie)
      }

      lcd.clear();
      lcd.print("MPU6050 OK"); // Confirmation que capteur est pr√™t
      delay(1000);
      lcd.clear();
    }

    void loop() {
      // Variables pour stocker les valeurs brutes (raw) lues depuis MPU6050
      int16_t rawAx, rawAy, rawAz;

      // Lecture des valeurs d'acc√©l√©ration brute sur 3 axes
      mpu.getAcceleration(&rawAx, &rawAy, &rawAz);

      // Conversion des valeurs brutes en unit√©s g (gravit√©)
      // Selon datasheet, la sensibilit√© est 16384 LSB/g en mode ¬±2g
      ax = rawAx / 16384.0;
      ay = rawAy / 16384.0;
      az = rawAz / 16384.0;

      // Calcul de la norme de l'acc√©l√©ration totale vectorielle
      // sqrt(x¬≤ + y¬≤ + z¬≤) -> donne l'intensit√© totale ressentie
      accel_norm = sqrt(ax * ax + ay * ay + az * az);

      // D√©tection de la direction dominante en fonction du seuil
      String direction = "";    // Texte √† afficher (direction d√©tect√©e)
      if (ax > threshold) { 
        direction = "Gauche";   // Si acceleration sur axe X positive > seuil
      }
      else if (ax < -threshold) {
        direction = "Droite";   // Si acceleration sur axe X n√©gative < -seuil
      }
      else if (ay > threshold) {
        direction = "Arriere";  // Si acceleration sur axe Y positive > seuil
      }
      else if (ay < -threshold) {
        direction = "Avant";    // Si acceleration sur axe Y n√©gative < -seuil
      }
      else if (az > threshold) {
        direction = "Haut";      // Si acceleration sur axe Z positive > seuil
      }
      else if (az < -threshold) {
        direction = "Bas";       // Si acceleration sur axe Z n√©gative < -seuil
      }
      else {
        direction = "Stable";    // Si aucune acceleration significative d√©tect√©e
      }
    
      // Affichage sur l'√©cran LCD
      lcd.clear();              // Efface l'√©cran √† chaque boucle
      lcd.setCursor(0, 0);      // Position curseur ligne 0, colonne 0
      lcd.print("Dir: ");       // Affiche label "Direction"
      lcd.print(direction);     // Affiche la direction d√©tect√©e

      lcd.setCursor(0, 1);      // Position curseur ligne 1, colonne 0
      lcd.print("Accel: ");     // Affiche label "Acc√©l√©ration"
      lcd.print(accel_norm, 2); // Affiche la norme de l'acc√©l√©ration avec 2 d√©cimales
      lcd.print(" g");          // Affiche unit√© g (gravit√©)

      delay(300);               // Pause de 300 ms avant prochaine lecture
    }
              </code></pre>
              </div>


          <h4>b. Code 2: </h4> 
            <p>
              Ce code n'utilise pas la librairie MPU6050 sur Arduino IDE.
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code_mpu2-ino', this)">üìã</button>
                <button onclick="telechargerCode('code_mpu2-ino', 'code_mpu2.ino', 'text/ino', this)">ü°á</button>
              </div>
              <pre><code id="code_mpu2-ino">
    #include &lt;Wire.h&gt;               // Biblioth√®que pour la communication I2C
    #include &lt;LiquidCrystal_I2C.h&gt;      // Biblioth√®que pour g√©rer l'√©cran LCD I2C

    const int MPU = 0x68;                // Adresse I2C du capteur MPU6050 (valeur par d√©faut)

    LiquidCrystal_I2C lcd(0x27, 16, 2); // Initialisation de l'√©cran LCD I2C (adresse 0x27, 16 colonnes, 2 lignes)

    // Variables pour stocker les donn√©es d'acc√©l√©ration
    float AccX, AccY, AccZ;
    // Variables pour stocker les donn√©es de gyroscope
    float GyroX, GyroY, GyroZ;

    // Angles calcul√©s √† partir de l'acc√©l√©rom√®tre
    float accAngleX, accAngleY;
    // Angles calcul√©s √† partir du gyroscope (int√©gr√©s)
    float gyroAngleX, gyroAngleY, gyroAngleZ;

    // Angles fusionn√©s (roll, pitch, yaw)
    float roll, pitch, yaw;

    // Erreurs calcul√©es lors de la calibration (offsets √† enlever)
    float AccErrorX, AccErrorY, GyroErrorX, GyroErrorY, GyroErrorZ;

    // Variables pour g√©rer le temps √©coul√© entre deux mesures
    float elapsedTime, currentTime, previousTime;

    // Compteur utilis√© pour la calibration
    int c = 0;

    void setup() {
      Serial.begin(19200);         // Initialisation du port s√©rie √† 19200 bauds pour debug
      Wire.begin();                // D√©marrage de la communication I2C

      // R√©veil du MPU6050 qui est en veille par d√©faut
      Wire.beginTransmission(MPU); // D√©marrer la transmission vers MPU
      Wire.write(0x6B);            // Registre PWR_MGMT_1 (gestion alimentation)
      Wire.write(0x00);            // Mettre √† 0 pour sortir du mode veille
      Wire.endTransmission(true);  // Fin de la transmission

      // Initialisation de l'√©cran LCD
      lcd.begin(16, 2);            // D√©finir taille LCD (16x2)
      lcd.backlight();             // Activer r√©tro√©clairage
      lcd.setCursor(0, 0);         // Positionner curseur au d√©but ligne 0
      lcd.print("Initialisation..."); // Message de d√©marrage
      delay(1000);                 // Pause d'1 seconde
      lcd.clear();                 // Effacer √©cran

      // Calibration automatique du capteur (calcul des erreurs √† soustraire)
      calculate_IMU_error();
      delay(20);                   // Petite pause
    }

    void loop() {
      // === Lecture des valeurs brutes de l'acc√©l√©rom√®tre ===
      Wire.beginTransmission(MPU);
      Wire.write(0x3B);                    // Adresse du registre de d√©but des donn√©es Accel
      Wire.endTransmission(false);        // Garder la communication ouverte
      Wire.requestFrom(MPU, 6, true);     // Lire 6 octets (2 par axe X,Y,Z)

      // Conversion des donn√©es brutes en valeurs en g (gravit√©)
      AccX = (Wire.read() << 8 | Wire.read()) / 16384.0; // Acc√©l√©ration X
      AccY = (Wire.read() << 8 | Wire.read()) / 16384.0; // Acc√©l√©ration Y
      AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0; // Acc√©l√©ration Z

      // Calcul des angles d'inclinaison (roll, pitch) avec acc√©l√©rom√®tre
      accAngleX = (atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI) - AccErrorX;
      accAngleY = (atan(-AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI) - AccErrorY;

      // === Lecture des valeurs brutes du gyroscope ===
      previousTime = currentTime;           // Sauvegarde du temps pr√©c√©dent
      currentTime = millis();                // Temps actuel en ms
      elapsedTime = (currentTime - previousTime) / 1000;  // Temps √©coul√© en secondes

      Wire.beginTransmission(MPU);
      Wire.write(0x43);                    // Adresse du registre de d√©but des donn√©es Gyro
      Wire.endTransmission(false);        // Garder la communication ouverte
      Wire.requestFrom(MPU, 6, true);     // Lire 6 octets (2 par axe X,Y,Z)

      // Conversion des donn√©es brutes en degr√©s/seconde
      GyroX = (Wire.read() << 8 | Wire.read()) / 131.0;
      GyroY = (Wire.read() << 8 | Wire.read()) / 131.0;
      GyroZ = (Wire.read() << 8 | Wire.read()) / 131.0;

      // Soustraction des erreurs calcul√©es lors de la calibration
      GyroX = GyroX - GyroErrorX;
      GyroY = GyroY - GyroErrorY;
      GyroZ = GyroZ - GyroErrorZ;

      // Int√©gration des vitesses angulaires pour obtenir les angles
      gyroAngleX += GyroX * elapsedTime;
      gyroAngleY += GyroY * elapsedTime;
      yaw += GyroZ * elapsedTime;

      // Application d'un filtre compl√©mentaire pour combiner acc√©l√©rom√®tre et gyroscope
      // On donne plus de poids au gyroscope (0.96) car plus pr√©cis sur court terme
      // L'acc√©l√©rom√®tre corrige la d√©rive du gyroscope sur le long terme (0.04)
      roll = 0.96 * gyroAngleX + 0.04 * accAngleX;
      pitch = 0.96 * gyroAngleY + 0.04 * accAngleY;

      // === D√©tection simple de la direction du mouvement en fonction des angles ===
      String direction = "haut"; // Valeur par d√©faut

      if (roll < -40 ) direction = "Avant";
      else if (roll < 80 && roll > 60) direction = "Arriere";
      else if (pitch > 15) direction = "Droite";
      else if (pitch < -15) direction = "Gauche";
      else if (pitch > 30) direction = "Haut";
      else if (pitch > 120 && roll > 100) direction = "Bas";

      // === Affichage de la direction d√©tect√©e sur l'√©cran LCD ===
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Direction:");
      lcd.setCursor(0, 1);
      lcd.print(direction);

      // Affichage des angles pour debug sur moniteur s√©rie
      Serial.print("Roll: "); Serial.print(roll);
      Serial.print(" | Pitch: "); Serial.print(pitch);
      Serial.print(" | Yaw: "); Serial.println(yaw);

      delay(300); // Pause avant prochaine lecture
    }

    // === Fonction pour calibrer automatiquement le capteur au d√©marrage ===
    void calculate_IMU_error() {
      // Calibration acc√©l√©rom√®tre : moyenne des angles calcul√©s sur plusieurs mesures
      while (c < 200) {
        Wire.beginTransmission(MPU);
        Wire.write(0x3B);
        Wire.endTransmission(false);
        Wire.requestFrom(MPU, 6, true);

        AccX = (Wire.read() << 8 | Wire.read()) / 16384.0;
        AccY = (Wire.read() << 8 | Wire.read()) / 16384.0;
        AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0;

        // Calcul des angles roll et pitch √† partir de l'acc√©l√©rom√®tre
        AccErrorX += atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI;
        AccErrorY += atan(-AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI;

        c++;
      }
      // Moyenne des erreurs calcul√©es
      AccErrorX /= 200;
      AccErrorY /= 200;
      c = 0; // R√©initialisation compteur

      // Calibration gyroscope : moyenne des valeurs lues au repos
      while (c < 200) {
        Wire.beginTransmission(MPU);
        Wire.write(0x43);
        Wire.endTransmission(false);
        Wire.requestFrom(MPU, 6, true);

        GyroX = Wire.read() << 8 | Wire.read();
        GyroY = Wire.read() << 8 | Wire.read();
        GyroZ = Wire.read() << 8 | Wire.read();

        GyroErrorX += GyroX / 131.0;
        GyroErrorY += GyroY / 131.0;
        GyroErrorZ += GyroZ / 131.0;

        c++;
      }
      // Moyenne des erreurs gyroscopiques
      GyroErrorX /= 200;
      GyroErrorY /= 200;
      GyroErrorZ /= 200;

      // Affichage des r√©sultats de calibration dans le moniteur s√©rie
      Serial.println("Calibration Terminee:");
      Serial.print("AccErrorX: "); Serial.println(AccErrorX);
      Serial.print("AccErrorY: "); Serial.println(AccErrorY);
      Serial.print("GyroErrorX: "); Serial.println(GyroErrorX);
      Serial.print("GyroErrorY: "); Serial.println(GyroErrorY);
      Serial.print("GyroErrorZ: "); Serial.println(GyroErrorZ);
    }
              </code></pre>

            </div>


          <h3 id="6-test1">6. Conception d'un prototype et d√©monstration</h3>
          
          <div class="image-container">
            <img src="images/Test1/Electronique/electronique1.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique2.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique3.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique4.jpg" alt="Prototype" class="image-small" />
          </div>

          <video controls width=auto>
            <source src="videos/Test1/Electronique/final_trial.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.
          </video>

          <video controls width=auto>
            <source src="videos/Test1/Electronique/prototype.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.
          </video>

          <h3 id="7-test1">7. Remarques</h3>
            <ul>
            <li>
              Pour des lectures plus stables et pr√©cises, il est possible d'int√©grer
              un filtre compl√©mentaire ou un filtre de Kalman.</li>
            <li>
              Ce projet constitue une excellente base pour des syst√®mes plus avanc√©s,
              tels que les contr√¥leurs, les robots auto-√©quilibr√©s ou les plateformes de stabilisation.</li>
          </ul> 
          
    
        <h3 id="8-test1">8. Conclusion</h3>
          <p>
            Ce projet nous a permis d‚Äôexplorer l‚Äôint√©gration d‚Äôun capteur inertiel dans un syst√®me embarqu√©, ainsi que de mettre en ≈ìuvre la d√©tection
            et l‚Äôaffichage en temps r√©el des mouvements de la main.
          </p>
           
          <p>
            Le module MPU6050 s‚Äôest r√©v√©l√© √™tre un outil efficace et accessible
            pour la d√©tection de l‚Äôorientation et des mouvements.
          </p>

          <p>
            Gr√¢ce √† sa compatibilit√© avec l‚Äô√©cosyst√®me Arduino et √† la disponibilit√© de biblioth√®ques
            d√©di√©es, le MPU6050 peut √™tre facilement int√©gr√© dans divers projets √©ducatifs ou de prototypage.
          </p>

          <p>
            L‚Äôaffichage des directions d√©tect√©es et des valeurs d‚Äôacc√©l√©ration sur un √©cran LCD 16x2
            offre une visualisation claire et p√©dagogique, id√©ale pour l‚Äôapprentissage des capteurs,
            de la programmation de microcontr√¥leurs et des interfaces homme-machine.
          </p>      
          
          <p>
            Au-del√† de son int√©r√™t p√©dagogique, ce syst√®me peut √™tre √©tendu √† des applications telles
            que le contr√¥le par gestes, la r√©alit√© virtuelle ou la robotique, avec la possibilit√©
            d‚Äôajouter une communication Bluetooth ou Wi-Fi pour renforcer l‚Äôinteractivit√©.
          </p>      

    </div>


        <div id="test2" class="subtab-content">
          <h2 id="projet2" class="projet-titre">Projet 2 - Bo√Æte noire</h2>
        <h3 id="1-test2">1. Introduction</h3>
        <p>
          Dans les syst√®mes embarqu√©s modernes, la collecte et l‚Äôanalyse de donn√©es 
          en temps r√©el sont essentielles pour le suivi et la s√©curit√© des √©quipements, 
          notamment dans des domaines critiques comme l‚Äôautomobile, l‚Äôaviation ou le 
          ferroviaire. S‚Äôinspirant du fonctionnement des bo√Ætes noires utilis√©es dans 
          ces industries, ce projet a pour objectif de concevoir un syst√®me embarqu√© 
          capable d‚Äôenregistrer et de transmettre en temps r√©el des donn√©es de mouvement 
          (vitesse et orientation) √† l‚Äôaide d‚Äôun capteur inertiel. 
          Les informations sont ensuite visualis√©es sur une station de contr√¥le via 
          un √©cran LCD. Ce projet s‚Äôinscrit dans le cadre du Tekbot Robotics Challenge 
          et fait appel √† plusieurs comp√©tences majeures : programmation directe des 
          microcontr√¥leurs ATmega328P sans utiliser de carte Arduino, communication via 
          le protocole I2C, conception de circuits imprim√©s avec KiCAD, r√©alisation 
          d‚Äôun bo√Ætier cubique de 7 cm, int√©gration mat√©rielle sur veroboard ou PCB,
          ainsi que la conception d‚Äôune alimentation sp√©cifique.
        </p>

        <h3 id="2-test2">2. Cahier des charges</h3>
          <h4>a. Objectifs fonctionnels</h4>
            <ul>
              <li>Lire les donn√©es de vitesse et d‚Äôorientation √† l‚Äôaide du MPU6050</li>
              <li>Utiliser le microcontr√¥leur ATmega328P sans carte Arduino</li>
              <li>Concevoir un circuit imprim√© (PCB) et une alimentation autonome</li>
              <li>Transmettre les donn√©es √† une station de contr√¥le via I2C</li>
              <li>Afficher les donn√©es sur un √©cran LCD en mode 4 bits</li>
            </ul>

          <h4>b. Contraintes techniques</h4>
            <ul>
              <li>Le cube doit mesurer 7x7x7 cm, avec une face ouverte pour voir le circuit</li>
              <li>Le microcontr√¥leur du cube agit en ma√Ætre I2C</li>
              <li>Le microcontr√¥leur de la station agit en esclave I2C</li>
              <li>Alimentation externe obligatoire, hors du cube</li>
              <li>Sch√©ma et PCB r√©alis√©s avec KiCad</li>
            </ul>
          <h4>c. Mat√©riels utilis√©s</h4>
            <ul>
              <li>ATmega328P √ó2 : <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">datasheet</a></li>
              <li>MPU6050 : <a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" target="_blank">datasheet</a></li>
              <li>LCD 16x2 (mode 4 bits) : <a href="https://www.gotronic.fr/pj2-sbc-lcd16x2-fr-1441.pdf?srsltid=AfmBOopmg8VyH8PQXxRcqE7GEvoyRwGRHeKVU9ZsKwGmKu13oZXhPhaJ" target="_blank">datasheet</a></li>
              <li>Alimentation</li>
            </ul>

        <h3 id="3-test2">3. Sch√©ma synoptique</h3>
        <p>
          Ce syst√®me embarqu√© est compos√© de deux unit√©s :
          une <strong>bo√Æte noire</strong> et une <strong>station de contr√¥le</strong>, 
          connect√©es via le bus I2C.
          La bo√Æte noire comprend un capteur MPU6050 qui d√©tecte les mouvements de la main 
          et envoie les donn√©es √† un microcontr√¥leur ATmega328P configur√© en ma√Ætre. 
          Celui-ci traite les donn√©es et les transmet √† la station de contr√¥le, 
          o√π un autre ATmega328P, configur√© en esclave, les re√ßoit. 
          Les informations sont ensuite affich√©es sur un √©cran LCD.
          Chaque unit√© est aliment√©e s√©par√©ment par une source de 5V.
        </p>
        <div class="image-container">
            <img src="https://github.com/user-attachments/assets/8b703337-a753-49e2-947b-a988aeb19c89" alt="Prototype"/>
        </div>

        <h3 id="4-test2">4. Description fonctionnelle des diff√©rents blocs du syst√®me</h3>
          <h4>a. Bloc d‚Äôalimentation</h4>
            <ul>
              <li><strong>Fonction principale</strong></li>
            <p>
              Ce bloc a pour objectif de fournir une tension continue et stable de 5V n√©cessaire 
              au fonctionnement des diff√©rents composants √©lectroniques du syst√®me, 
              notamment le capteur <strong>MPU6050</strong>, les <strong>microcontr√¥leurs ATmega328P</strong> et l'√©cran <strong>LCD</strong>.
            </p>

              <li><strong>Fonctionnement</strong></li>
            <p>
              On utilise trois batteries de Li-Ion 3,7V rechargeables mont√©es en s√©rie pour obtenir environ 12V.
            </p>
            <p>
              Le <strong>r√©gulateur L7805</strong> re√ßoit ce 12V en entr√©e (Vin) et fournit du 5V en sortie (Vout).
            </p>
            <p>
              Deux condensateurs (330nF <strong>√† l‚Äôentr√©e</strong> et 100nF <strong>√† la sortie</strong>) sont utilis√©s pour stabiliser la tension et filtrer les parasites:
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/690d4b70-85dd-4cbb-bff8-a1c31e7033fd" alt="schema"/>
            </div>
            <p>
               La simulation sur proteus : Les condensateurs de filtrage ont √©t√© omis dans ce sch√©ma pour simplifier la repr√©sentation, bien qu‚Äôils soient indispensables en pratique pour assurer la stabilit√© et r√©duire le bruit.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/a75470b7-4158-495d-adb8-76909df0c935" alt="schema"/>
            </div>

            <video controls width=auto>
              <source src="videos/Test2/Electronique/test.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.                   
            </video>

            </ul>
          
          <h4>b. Bloc d‚Äôentr√©e(dans la boite noire)</h4>
          <p>
            Nous avons choisi le capteur MPU6050 parce qu‚Äôil int√®gre un acc√©l√©rom√®tre et un 
            gyroscope dans un seul composant. Cela permet de mesurer les mouvements et les rotations 
            de la main avec pr√©cision. Il est facile √† utiliser gr√¢ce au protocole I2C, et il fonctionne 
            bien avec le microcontr√¥leur ATmega328P. En plus, il est peu co√ªteux et largement utilis√© 
            dans les projets embarqu√©s. D‚Äôautres capteurs peuvent faire un travail similaire, comme le 
            MPU9250 (qui ajoute un magn√©tom√®tre), le LSM6DS3 (plus r√©cent et plus √©conome), ou le ADXL34
          </p>
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/2c989400-0c29-46dc-907c-dcd7208a431b" alt="schema"/>
          </div>

          <h4>c. Bloc de commande(dans la boite noire)</h4>
            <ul>
              <li><strong>√âtape 1 : Prise en main du microcontr√¥leur ATmega328P</strong></li>
            <p>
              Avant de d√©marrer le syst√®me complet, l‚Äô√©quipe s‚Äôest d‚Äôabord focalis√©e sur le 
              microcontr√¥leur ATmega328P. L‚Äôobjectif √©tait de comprendre pleinement sa structure 
              interne, ses broches, ainsi que la mani√®re de le configurer et de le simuler.
            </p>
            <p>
              Nous avons √©tudi√© ses principales caract√©ristiques et son brochage :
            </p>
            <ul>
              <li>Le format DIP √† 28 broches, comme dans les cartes Arduino Uno</li>
              <li>Les broches d‚ÄôE/S num√©riques D0 √† D13, pour piloter des LED, relais, etc.</li>
              <li>Les entr√©es analogiques A0 √† A5, pour la lecture de capteurs</li>
              <li>L‚Äôinterface I2C via SDA (PC4) et SCL (PC5)</li>
              <li>La communication s√©rie UART via TX (PD1) et RX (PD0)</li>
              <li>Les broches d‚Äôalimentation : VCC, GND, AVCC, AREF</li>
              <li>La broche RESET, g√©n√©ralement tir√©e √† l‚Äô√©tat haut via une r√©sistance</li>
              <li>Les broches XTAL1/XTAL2 pour le quartz (utilis√© plus tard)</li>
            </ul>
            <p>
              Ces √©l√©ments nous ont permis de pr√©parer une simulation fiable sous Proteus 
              pour la suite du projet.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/62775b28-f4f7-42ed-b677-140ee88c7769" alt="schema"/>
            </div>


              <li><strong>√âtape 2 : Simulation basique de l‚ÄôATmega328P dans Proteus</strong></li>
            <p>
              Apr√®s avoir √©tudi√© la configuration du microcontr√¥leur, nous avons r√©alis√© une premi√®re 
              simulation simple sous Proteus, afin de valider son fonctionnement dans un environnement 
              simul√©.
            </p>
            <p>
              √Ä ce stade :
            </p>
            <ul>
              <li>Nous n'avons pas utilis√© les connexions d‚Äôalimentation (VCC/AVCC) ni de quartz externe, car elles ne sont pas obligatoires pour les logiques simples dans Proteus.</li>
              <li>Nous nous sommes concentr√©s sur le comportement des broches dans un exemple r√©el.</li>
            </ul>
            <p>
              Sc√©nario de simulation : Nous avons con√ßu un syst√®me simple dans lequel :
            </p>
            <ul>
              <li>Un bouton poussoir est connect√© √† une entr√©e num√©rique.</li>
              <li>
                Nous nous sommes concentr√©s sur le comportement des broches dans un exemple r√©el. 
                Lorsqu‚Äôon appuie sur le bouton, l‚ÄôATmega active un relais via une sortie num√©rique.
              </li>
              <li>Ce relais commande une lampe LED 12V, simulant une charge r√©elle.</li>
            </ul>
            <p>
              Le code Arduino correspondant a √©t√© compil√© dans l‚ÄôIDE Arduino, puis le fichier .hex 
              g√©n√©r√© a √©t√© int√©gr√© dans Proteus pour tester le comportement du circuit.
            </p>     
            <video controls width=auto>
            <source src="https://github.com/user-attachments/assets/d1cc5dd5-9109-4822-be6e-245693643c00" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>

            <p>
              Observation :
            </p>
            <ul>
              <li>Lorsque le bouton est press√©, le relais s‚Äôactive et allume la LED.</li>
              <li>Le comportement observ√© est conforme √† la logique attendue et coh√©rente.</li>
            </ul>
          </ul>

            <h4>d. Bloc d‚Äôaffichage de la station du controle</h4>
            <p>
              Pour l‚Äôaffichage des donn√©es au niveau de la station de contr√¥le, nous avons opt√© pour 
              un √©cran LCD √©quip√© d‚Äôun module I2C. Ce choix permet de simplifier le montage √©lectronique 
              en r√©duisant consid√©rablement le nombre de connexions n√©cessaires entre le microcontr√¥leur 
              et l‚Äô√©cran. Gr√¢ce √† cette interface, seules deux lignes (SDA et SCL) suffisent pour 
              transmettre les informations, ce qui laisse davantage de broches disponibles pour d‚Äôautres 
              composants. L‚Äô√©cran LCD I2C assure ainsi une lecture claire et en temps r√©el des donn√©es 
              de vitesse et d‚Äôorientation envoy√©es par la bo√Æte noire.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/29db70ec-851d-4a14-a918-5cb94e43d4d7" alt="schema"/>
            </div>
            
          <h4>e. La communication I2C</h4>
            <p>
              Ce document constitue une pr√©sentation d√©taill√©e et approfondie du protocole I2C 
              (Inter-Integrated Circuit), qui est un standard de communication s√©rie synchrone tr√®s 
              r√©pandu dans l‚Äô√©lectronique embarqu√©e. Ce protocole facilite l‚Äô√©change d‚Äôinformations 
              entre un ou plusieurs ma√Ætres et plusieurs p√©riph√©riques esclaves en utilisant seulement 
              deux fils, simplifiant ainsi les connexions mat√©rielles tout en assurant une communication 
              fiable et efficace.
            </p>

            <ul>
              <li><strong>Principe de fonctionnement</strong></li>
            <p>
              <a href="https://fr.wikipedia.org/wiki/I2C" target="_blank">Protocole I2C</a> (Inter-Integrated Circuit), d√©velopp√© par Philips (aujourd‚Äôhui NXP) dans les ann√©es 1980, 
              est un standard mondial pour la communication s√©rie entre circuits int√©gr√©s, 
              surtout dans les syst√®mes embarqu√©s. Il utilise un bus bidirectionnel √† deux fils : 
              SDA pour les donn√©es et SCL pour l‚Äôhorloge, permettant √† plusieurs p√©riph√©riques de 
              partager le m√™me canal tout en g√©rant pr√©cis√©ment l‚Äôacc√®s.
              Contrairement √† des protocoles comme SPI, I2C minimise le nombre de connexions 
              n√©cessaires, ce qui simplifie le routage sur circuit imprim√© et r√©duit les co√ªts. 
              Ce protocole est largement utilis√© dans des domaines vari√©s : 
              automobile, domotique, informatique, etc.
            </p>
            <p>
              L'I2C fonctionne selon un mod√®le <a href="https://www.ionos.fr/digitalguide/serveur/know-how/le-principe-master/slave/" target="_blank">ma√Ætre-esclave</a>: un ou plusieurs ma√Ætres contr√¥lent la communication, et les esclaves r√©pondent aux requ√™tes. 
              Chaque communication commence par une condition <strong>Start</strong>, 
              suivie de <strong>l‚Äôadresse de l‚Äôesclave</strong> et d‚Äôun bit de direction 
              (lecture/√©criture). Les donn√©es sont ensuite √©chang√©es octet par octet, 
              chaque octet √©tant confirm√© par un bit d‚Äôacquittement(ACK). 
              La communication se termine par une condition <strong>Stop</strong>, qui lib√®re le bus.
            </p>
            <p>
              Techniquement, I2C utilise des lignes ouvertes (open-drain) : 
              les dispositifs ne peuvent que tirer les lignes vers le bas, 
              tandis que des r√©sistances pull-up maintiennent le niveau haut par d√©faut. 
              Cela √©vite les conflits, notamment en mode multi-ma√Ætres.
              Enfin, I2C offre une grande flexibilit√© en termes de vitesse, du mode standard 
              (100 kHz) au mode rapide (jusqu‚Äô√† 3,4 MHz) et au-del√† dans certaines variantes 
              propri√©taires.
            </p>
            
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/18f95ad8-0fa3-49cb-99ce-52408ff42054" alt="schema"/>
            </div>

            <li><strong>Prise de contr√¥le du bus</strong></li>
            <p>
              La prise de contr√¥le du bus par un ma√Ætre d√©bute par une condition Start (S), 
              qui est un √©v√©nement distinctif sur le bus. Cette condition correspond √† une transition 
              sur la ligne SDA de l‚Äô√©tat haut √† l‚Äô√©tat bas, alors que la ligne SCL est maintenue √† 
              l‚Äô√©tat haut. Cette s√©quence particuli√®re est d√©tect√©e par tous les p√©riph√©riques 
              connect√©s au bus, qui entrent alors en mode √©coute, pr√™ts √† recevoir des donn√©es.
            </p>
            <p>
              La condition Start joue un r√¥le fondamental : elle marque l‚Äôexclusivit√© du ma√Ætre sur 
              le bus, ce qui √©vite les collisions ou l‚Äôinterf√©rence avec d‚Äôautres ma√Ætres √©ventuels. 
              Elle sert aussi de synchronisation initiale √† la transmission de donn√©es, 
              en assurant que tous les appareils sont synchronis√©s sur le d√©but de la communication.
            </p>
            <p>
              Les r√©sistances pull-up sur les lignes SDA et SCL maintiennent ces lignes √† 
              un √©tat logique haut par d√©faut, garantissant ainsi que le bus est en repos 
              quand aucune communication n‚Äôa lieu.
            </p>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/592b1e08-6f4c-4e0a-972b-d53158d6ed80" alt="schema" class="image-mean"/>
              <!-- <img src="https://github.com/user-attachments/assets/2eeeefcc-9f5b-47ae-8ac2-8a300c7d97c5" alt="schema" class="image-mean"/> -->
            </div>
            <div class="image-container">
              <!-- <img src="https://github.com/user-attachments/assets/592b1e08-6f4c-4e0a-972b-d53158d6ed80" alt="schema" class="image-mean"/> -->
              <img src="https://github.com/user-attachments/assets/2eeeefcc-9f5b-47ae-8ac2-8a300c7d97c5" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Transmission d'un octet</strong></li>
            <p>
              La transmission des donn√©es sur le bus I2C s‚Äôeffectue par octets (8 bits). 
              Chaque bit est transmis s√©quentiellement, en commen√ßant par le bit le plus significatif 
              (MSB).
            </p>
            <p>
              Le protocole impose que chaque bit soit plac√© sur la ligne SDA pendant que la ligne SCL 
              est √† l‚Äô√©tat bas. Ensuite, la ligne SCL passe √† l‚Äô√©tat haut, moment o√π 
              le r√©cepteur lit la valeur pr√©sente sur la ligne SDA. 
              Lorsque la ligne SCL redescend √† l‚Äô√©tat bas, 
              l‚Äô√©metteur peut placer le bit suivant sur SDA, et ainsi de suite.
            </p>
            <p>
              Apr√®s l‚Äôenvoi des 8 bits d‚Äôun octet, 
              la ligne SDA est lib√©r√©e pendant le 9e cycle d‚Äôhorloge. 
              C‚Äôest alors au r√©cepteur de signaler par un bit d‚Äôacquittement (ACK) s‚Äôil a correctement 
              re√ßu l‚Äôoctet, en tirant la ligne SDA √† l‚Äô√©tat bas. S‚Äôil ne tire pas SDA √† z√©ro, 
              un bit de non-acquittement (NACK) est d√©tect√©, ce qui indique que la communication 
              doit √™tre interrompue ou qu‚Äôune erreur s‚Äôest produite.
            </p>
            <p>
              Ce m√©canisme d‚Äô<strong>ACK/NACK</strong> est crucial car il assure la fiabilit√© 
              des transmissions, permettant au ma√Ætre de savoir si l‚Äôesclave est disponible 
              et pr√™t √† recevoir ou envoyer des donn√©es.
            </p>

            <li><strong>Transmission d'une adresse</strong></li>
            <p>
              Apr√®s la condition Start, le ma√Ætre envoie un octet d‚Äôadresse pour 
              identifier l‚Äôesclave avec lequel il souhaite communiquer. 
              L‚Äôadresse est g√©n√©ralement cod√©e sur 7 bits, suivis d‚Äôun bit R/W indiquant 
              si la transaction sera une lecture ou une √©criture.
            </p>
            <p>
              Le protocole pr√©voit aussi une extension 10 bits 
              pour les r√©seaux comportant un grand nombre de p√©riph√©riques, 
              mais cette extension est moins fr√©quemment utilis√©e.
            </p>
            <p>
              Tous les p√©riph√©riques esclaves surveillent le bus 
              et comparent l‚Äôadresse re√ßue avec leur propre adresse. 
              Celui qui reconna√Æt son adresse r√©pond alors par un bit ACK en tirant la ligne SDA 
              √† l‚Äô√©tat bas pendant le 9e bit. Les autres esclaves restent silencieux 
              jusqu‚Äô√† la prochaine s√©quence.
            </p>
            <p>
              Cette √©tape est essentielle car elle garantit que seules les communications 
              destin√©es √† un p√©riph√©rique sp√©cifique sont trait√©es, 
              √©vitant ainsi toute interf√©rence entre plusieurs p√©riph√©riques sur le m√™me bus.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/d0ee80b6-b169-4cd5-9149-25fd731a3583" alt="schema" class="image-mean"/>
            </div>

            <li><strong>√âcriture d'une donn√©e</strong></li>
            <p>
              Une fois l‚Äôadresse reconnue par l‚Äôesclave, 
              la phase de transfert des donn√©es peut commencer. 
              Le ma√Ætre transmet alors les octets de donn√©es √† l‚Äôesclave, 
              chaque octet √©tant suivi d‚Äôun bit ACK envoy√© par l‚Äôesclave pour confirmer la bonne r√©ception.  
            </p>
            <p>
              Le protocole permet d‚Äôenvoyer autant d‚Äôoctets que n√©cessaire dans une m√™me communication, ce qui permet des transferts efficaces et continus.
            </p>
            <p>
              Pour terminer la communication, le ma√Ætre g√©n√®re une condition Stop (P), qui correspond √† une transition de la ligne SDA de l‚Äô√©tat bas √† l‚Äô√©tat haut alors que la ligne SCL est haute. Cette s√©quence indique √† tous les p√©riph√©riques que la transmission est termin√©e et que le bus est lib√©r√© pour une autre communication.
            </p>
            <p>
              Il existe √©galement une condition Restart, qui est une condition Start g√©n√©r√©e sans condition Stop pr√©alable, permettant de cha√Æner plusieurs op√©rations sur le m√™me bus sans interruption.
            </p>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/cd3818b4-20a3-4ab2-8ad2-63cb27b47d49" alt="schema" class="image-mean"/>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/61143d18-67bd-4ae0-a9b4-aafa01f3786f" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Arbitration</strong></li>
            <p>
              Le protocole I2C est con√ßu pour supporter un mode multi-ma√Ætres, o√π plusieurs ma√Ætres peuvent tenter d‚Äôacc√©der au bus simultan√©ment. Pour √©viter les conflits, un m√©canisme d‚Äôarbitrage est mis en place.
            </p>
            <p>
              Lorsqu‚Äôun ma√Ætre commence √† transmettre, il surveille la ligne SDA et la compare avec ce qu‚Äôil souhaite envoyer. Si un ma√Ætre d√©tecte que la ligne SDA est forc√©e √† l‚Äô√©tat bas par un autre ma√Ætre alors qu‚Äôil tente de la maintenir haute, il comprend qu‚Äôil a perdu l‚Äôarbitrage et abandonne imm√©diatement la transmission, laissant le bus libre au ma√Ætre dominant.
            </p>
            <p>
              Ce m√©canisme garantit qu‚Äôaucune collision √©lectrique ne se produit sur le bus et que seule une source transmet √† un instant donn√©. C‚Äôest une des forces du protocole I2C, qui permet une coexistence harmonieuse de plusieurs ma√Ætres sur un m√™me bus.
            </p>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/2a51d266-e7b7-4805-9f25-3cc9b081af5d" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Clock Stretching</strong></li>
            <p>
              Le clock stretching est une fonctionnalit√© du protocole I2C qui permet √† un esclave de ralentir temporairement la communication lorsqu‚Äôil n‚Äôest pas pr√™t √† envoyer ou recevoir des donn√©es. Cela se fait en gardant la ligne SCL √† l‚Äô√©tat bas (LOW), emp√™chant ainsi le ma√Ætre de continuer √† envoyer des impulsions d‚Äôhorloge. Une fois que l‚Äôesclave est pr√™t, il lib√®re la ligne SCL, permettant au ma√Ætre de reprendre la transmission. Cette technique est utile, par exemple, lorsque le capteur a besoin de plus de temps pour traiter ou pr√©parer les donn√©es. Le ma√Ætre doit respecter cet √©tirement d‚Äôhorloge pour √©viter des erreurs de communication.
            </p>
            
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/3b85fa91-3ed1-4b41-8336-1256be15648b" alt="schema" class="image-mean"/>
            </div>

            </ul>

        <h4>f. Communication I2C entre MPU6050 et ATmega328P</h4>
            <p>
              Dans notre projet, le microcontr√¥leur ATmega328P communique avec le capteur MPU6050 √† l‚Äôaide du protocole I2C. Ce protocole permet de transmettre les donn√©es d‚Äôacc√©l√©ration et de rotation via deux fils (SDA et SCL). Le MPU6050 agit comme esclave, et l‚ÄôATmega328P comme ma√Ætre.
            </p>
            <ul>
              <li><strong>Fonctionnement de la liaison I2C</strong></li>
            <p>
              La connexion mat√©rielle entre le MPU6050 et l‚ÄôATmega328P s‚Äôeffectue via le protocole I2C (Inter-Integrated Circuit), qui utilise deux lignes de communication :
            </p>
            <ul>
              <li>SDA (Serial Data Line) : ligne bidirectionnelle pour l‚Äô√©change des donn√©es, connect√©e √† la broche PC4 de l‚ÄôATmega328P.</li>
              <li>SCL (Serial Clock Line) : ligne d‚Äôhorloge g√©n√©r√©e par le ma√Ætre, connect√©e √† la broche PC5 de l‚ÄôATmega328P.</li>
            </ul>
            <p>
              Sur le bus I2C, le dispositif qui initie la communication est appel√© ma√Ætre, tandis que celui qui r√©pond s‚Äôappelle esclave. Dans notre cas :
              L‚ÄôATmega328P joue le r√¥le de ma√Ætre, c‚Äôest lui qui contr√¥le le bus, g√©n√®re l‚Äôhorloge, et initie les √©changes.
              Le MPU6050 est l‚Äôesclave, il attend que le ma√Ætre lui demande des donn√©es sp√©cifiques.
              Le ma√Ætre d√©marre la communication en envoyant une adresse unique correspondant √† l‚Äôesclave (ici l‚Äôadresse I2C du MPU6050, g√©n√©ralement 0x68), suivie d‚Äôune commande indiquant quel registre ou donn√©e il souhaite lire.
              </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/6cea5b00-bb19-4816-af14-adf2e965201a" alt="schema"/>
            </div>


              <li><strong>Envoi des commandes et r√©ception des donn√©es</strong></li>
            <p>
              La communication suit ce processus 
            </p>
            <ul>
              <li>Le ma√Ætre (ATmega328P) commence par envoyer une commande au MPU6050, qui consiste √† sp√©cifier l‚Äôadresse du registre interne dont il souhaite lire la valeur. Par exemple, pour lire l‚Äôacc√©l√©ration sur l‚Äôaxe X, il envoie l‚Äôadresse du registre ACCEL_XOUT_H.</li>
              <li>Cette commande est envoy√©e via le bus I2C sous forme d‚Äôune trame contenant l‚Äôadresse de l‚Äôesclave, suivie de l‚Äôadresse du registre cibl√©.</li>
              <li>Une fois la commande re√ßue, le MPU6050 pr√©pare la donn√©e correspondante et la transmet d√®s que le ma√Ætre la demande.</li>
              <li>Le ma√Ætre r√©cup√®re alors la ou les valeurs envoy√©es par le capteur, g√©n√©ralement sur plusieurs octets, qu‚Äôil traite ensuite pour en extraire l‚Äôinformation de mouvement (acc√©l√©ration, rotation, temp√©rature).</li>
            </ul>
            
          </ul>

      <h3 id="5-test2">5. Etapes de validation avant PCB</h3>
          <h4>a. √âtape 1 : Communication I2C entre deux Arduino (Test de base)</h4>
            <p>
              Afin de valider le fonctionnement de la communication I2C entre deux microcontr√¥leurs en utilisant un exemple simple : un bouton poussoir et une LED.
            </p>
            <p>
              Composants utilis√©s :
            </p>
            <ul>
              <li>2 cartes Arduino UNO</li>
              <li>1 bouton poussoir (sur le ma√Ætre)</li>
              <li>1 LED (sur l‚Äôesclave)</li>
              <li>C√¢blage SDA/SCL entre les deux cartes</li>
            </ul>

            <p>
              Fonctionnement  :
            </p>
            <ul>
              <li>L‚ÄôArduino ma√Ætre lit l‚Äô√©tat d‚Äôun bouton poussoir connect√© en entr√©e.</li>
              <li>Cet √©tat (appuy√© ou rel√¢ch√©) est transmis √† l‚ÄôArduino esclave via le protocole I2C.</li>
              <li>L‚Äôesclave re√ßoit cette donn√©e et contr√¥le une LED : elle s‚Äôallume si le bouton est appuy√©, s‚Äô√©teint sinon.</li>
            </ul>

            <p>
              But de l'√©tape : 
            </p>
            <ul>
              <li>Apprendre √† configurer le bus I2C (ma√Ætre/esclave).</li>
              <li>V√©rifier la synchronisation et la fiabilit√© de la communication.</li>
              <li>Observer une r√©ponse simple √† un signal I2C.</li>
            </ul>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/88f6527a-9f2b-40c0-a4ea-c1e3489a3cf6" alt="schema"/>
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/f24d194f-d3f9-40da-8c5a-b3b9a5e75ebc" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>
        
        <h4>b. √âtape 2 : Remplacement par des modules r√©els (MPU6050 et LCD)</h4>
            <p>
              Pour simuler une application plus r√©aliste en utilisant des capteurs r√©els(MPU6050) et un afficheur(lCD), tout en gardant la communication I2C entre deux cartes.
            </p>
            <p>
              Composants utilis√©s :
            </p>
            <ul>
              <li>MPU6050 (capteur acc√©l√©rom√®tre/gyroscope) sur le ma√Ætre</li>
              <li>√âcran LCD (type I2C 16x2) sur l‚Äôesclave</li>
              <li>Deux cartes Arduino</li>
            </ul>

            <p>
              Fonctionnement  :
            </p>
            <ul>
              <li>Le capteur MPU6050 collecte les donn√©es d‚Äôacc√©l√©ration et de rotation.</li>
              <li>Ces donn√©es sont lues par l‚ÄôArduino ma√Ætre via I2C.</li>
              <li>Le ma√Ætre envoie ensuite les valeurs trait√©es √† l‚Äôesclave.</li>
              <li>L‚ÄôArduino esclave re√ßoit les donn√©es et les affiche sur le LCD.</li>
            </ul>

            <p>
              But de l'√©tape : 
            </p>
            <ul>
              <li>Remplacer des composants de test par des modules intelligents.</li>
              <li>Manipuler un capteur complexe avec acquisition de donn√©es.</li>
              <li>G√©rer l'affichage distant d'informations, toujours via I2C.</li>
              <li>Approfondir le protocole I2C dans un cas concret (multi-esclaves potentiels, synchronisation).</li>
            </ul>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/4bf55be3-fb1c-43e9-98be-2359a4609619" alt="schema"/>
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/1c67d0e5-90eb-4aa1-bebf-cd58e934528a" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>

        <h4>c. √âtape 3 : Int√©gration avec ATmega328P (pr√©paration au PCB)</h4>
            <p>
             Afin de remplacer la carte Arduino par le <strong>microcontr√¥leur brut</strong> (ATmega328P), et de simuler les conditions r√©elles d‚Äôun circuit imprim√©.
            </p>
            <p>
              Composants utilis√©s :
            </p>
            <ul>
              <li>2√ó ATmega328P</li>
              <li>2√ó Quartz</li>
              <li>4√ó Condensateurs 22 pF</li>
              <li>1√ó MPU6050</li>
              <li>1√ó √âcran LCD 16x2 avec interface I2C</li>
              <li>2√ó Boutons poussoirs</li>
              <li>2√ó R√©sistances 10 kŒ©</li>
              <li>Fils de connexion (Dupont)</li>
              <li>Breadboard</li>
            </ul>

            <p>
              Fonctionnement  :
            </p>
            <ul>
              <li>L‚ÄôATmega328P est programm√© avec le m√™me code que celui utilis√© sur une carte Arduino, √† l‚Äôaide d‚Äôun programmateur externe (comme USBasp ou Arduino as ISP).</li>
              <li>Les deux ATmega328P communiquent via le protocole I2C :</li>
              <ul>
                <li>L‚Äôun joue le r√¥le de ma√Ætre (elle collecte les donn√©es du MPU6050).</li>
                <li>L‚Äôautre joue le r√¥le d‚Äôesclave (elle affiche les donn√©es sur un √©cran LCD I2C).</li>
              </ul>
              <li>Les microcontr√¥leurs sont utilis√©s en mode "standalone" (hors carte de d√©veloppement).</li>
              <li>Connect√©s sur breadboard avec :</li>
              <ul>
                <li>Un quartz et deux condensateurs 22 pF pour chaque ATMEGA328P pour g√©n√©rer l‚Äôhorloge.</li>
                <li>Une alimentation 5V stable.</li>
                <li>Un bouton poussoir reli√© √† la broche RESET de chaque ATmega.</li>
                <li>Une r√©sistance de 10 kŒ© connect√©e entre la broche RESET et VCC, pour garantir un red√©marrage stable.</li>
              </ul>
            </ul>
            
            <p>
              But de l'√©tape : 
            </p>
            <ul>
              <li>S‚Äôassurer que le microcontr√¥leur fonctionne correctement en mode autonome.</li>
              <li>Tester la communication I2C dans les conditions mat√©rielles r√©elles du futur PCB.</li>
              <li>Pr√©parer l‚Äôint√©gration finale des composants sur un PCB personnalis√©.</li>
            </ul>

            <div class="image-container">
              <img src="images/Test2/Electronique/image.png" alt="schema" class="image-small"/>              
              <!-- <img src="https://github-production-user-asset-6210df.s3.amazonaws.com/215927366/457011835-60ee4f9b-8e22-4bce-a59e-369cb7b13c1f.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250619%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250619T145330Z&X-Amz-Expires=300&X-Amz-Signature=d162c0993c215ea0a0799f3edb3868bd47548c3773ec9747b8ee027303135831&X-Amz-SignedHeaders=host" alt="schema" class="image-small"/> -->
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/9b0e3092-58c1-435a-8556-9573676f7728" type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>


          <div class="code-container">
            <p>Code_maitre.ino </p>
            <div class="btn-bar">
              <button onclick="copierCode('Code_maitre-ino', this)">üìã</button>
              <button onclick="telechargerCode('Code_maitre-ino', 'Code_maitre.ino', 'text/ino', this)">ü°á</button>
            </div>
            <pre><code id="Code_maitre-ino">
    #include &lt;Wire.h&gt;        
    #include &lt;MPU6050.h&gt;  

    MPU6050 mpu;

    float ax, ay, az;
    const float threshold = 0.2;
    String direction = "";

    void setup() {
      Serial.begin(9600);
      Wire.begin();      // Ma√Ætre
      mpu.initialize();

      if (!mpu.testConnection()) {
        Serial.println("Erreur MPU6050");
        while (1);
      }

      Serial.println("MPU6050 OK");
    }

    void loop() {
      int16_t rawAx, rawAy, rawAz;
      mpu.getAcceleration(&rawAx, &rawAy, &rawAz);

      ax = rawAx / 16384.0;
      ay = rawAy / 16384.0;
      az = rawAz / 16384.0;

      // D√©tection de direction
      if (ax > threshold) direction = "Gauche";
      else if (ax < -threshold) direction = "Droite";
      else if (ay > threshold) direction = "Arriere";
      else if (ay < -threshold) direction = "Avant";
      else if (az > threshold) direction = "Haut";
      else if (az < -threshold) direction = "Bas";
      else direction = "Stable";

      // Envoi vers esclave
      Wire.beginTransmission(8);         // adresse esclave
      Wire.write(direction.c_str());     // envoyer la direction comme texte
      Wire.endTransmission();

      Serial.print("Direction envoy√©e : ");
      Serial.println(direction);

      delay(300);
    }                      
              </code></pre>
            </div>

          <div class="code-container">
            <p>Code_esclave.ino </p>
            <div class="btn-bar">
              <button onclick="copierCode('Code_esclave-ino', this)">üìã</button>
              <button onclick="telechargerCode('Code_esclave-ino', 'Code_esclave.ino', 'text/ino', this)">ü°á</button>
            </div>
            <pre><code id="Code_esclave-ino">
    #include &lt;Wire.h&gt;               // Biblioth√®que pour communication I2C
    #include &lt;LiquidCrystal_I2C.h&gt;  // Biblioth√®que pour √©cran LCD I2C
    #include &lt;MPU6050.h&gt;  
    
    LiquidCrystal_I2C lcd(0x27, 16, 2);  // LCD I2C

    String receivedDirection = "";

    void setup() {
      Wire.begin(8);  // Adresse de l'esclave
      Wire.onReceive(receiveData);

      lcd.init();
      lcd.backlight();
      lcd.setCursor(0, 0);
      lcd.print("Pret a recevoir");
    }

    void loop() {
      // Affiche la derni√®re direction re√ßue
      lcd.setCursor(0, 0);
      lcd.print("Dir:            "); // Nettoyer la ligne
      lcd.setCursor(5, 0);
      lcd.print(receivedDirection);
      
      delay(200);
    }

    void receiveData(int bytes) {
      receivedDirection = ""; // r√©initialiser

      while (Wire.available()) {
        char c = Wire.read();
        receivedDirection += c;
      }

      Serial.print("Recu : ");
      Serial.println(receivedDirection);
    }         
              </code></pre>
            </div>
             
        <h4>Pourquoi cette D√©marche ?</h4>
        <p>
          La r√©alisation d‚Äôun PCB n√©cessite des choix pr√©cis de composants et un bon fonctionnement garanti en amont. Cette d√©marche par √©tapes nous a permis de :
        </p>
        <ul>
          <li>Identifier les erreurs √©ventuelles (bruit sur la ligne I2C, mauvais c√¢blage, alimentation instable‚Ä¶).</li>
          <li>Tester progressivement les modules dans un environnement de d√©veloppement.</li>
          <li>R√©duire le risque d‚Äôerreur lors de la conception du PCB.</li>
          <li>Avoir une base fonctionnelle avant le passage √† la fabrication.</li>
        </ul>
      

      <h3 id="6-test2">6. R√©alisation du PCB</h3>
        <h4>a. PCB de la boite noire</h4>
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/4daa371b-60f8-45ec-88ee-bb22b75d8ffa" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Conception du sch√©ma int√©grant le microcontr√¥leur ATmega328P, le capteur MPU-6050 et les connecteurs.
          </p>
        </div>
        
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/f9ea1c3f-b691-48d5-a4c3-829fab5aea9e" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Attribution des empreintes physiques correspondant aux composants.
          </p>
        </div>
     
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/c029f01b-0e0d-4864-b490-48a2cf801f62" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Verificaton des erreurs (DRC)
          </p>
        </div>
        
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/64ee506b-c1e7-46de-824a-649cb73a8f54" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Ajustement de la disposition pour optimiser l‚Äôespace et faciliter le routage.
          </p>
        </div>

        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/968138f4-4dd2-4971-a71d-c887548e13d0" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Routage des pistes
          </p>
        </div>
        

        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/32678869-7ea0-4449-a07f-74b8b4168ad1" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            D√©finition des contours du PCB (Edge Cuts)
          </p>
        </div>

        <div class="image-container">
          <p class = "txt_center">
            Visualisation 3D du PCB
          </p>
          <img src="https://github.com/user-attachments/assets/0b16bd0a-1850-40e2-8e45-25d22ce4fcd2" alt="pcb" class="image-mean" />
        </div>
        <video controls width=auto>
          <source src="https://github.com/user-attachments/assets/f897ede6-44c2-42a2-96d0-31dc648d50c1" type="video/mp4">
          Votre navigateur ne supporte pas la vid√©o HTML5.                   
        </video>

        <p class="txt_center">
          <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/tree/main/Test2/Electronique/boite_noire" target="_blank" class="download-link">lien vers les fichiers du pcb de la boite noire</a>
        </p>

      <h4>b. PCB de la station de contr√¥le</h4>
       
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/9f6d6881-972e-4cf5-aead-8e29ac9a7a28" alt="pcb" class="image-mean"/>
            <p class = "txt_center">
              Conception du sch√©ma int√©grant le microcontr√¥leur ATmega328P, le capteur MPU-6050 et les connecteurs.
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/f0cfca43-da82-427a-95cb-d35d16d0c2fa" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Anotation
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/281e78ea-b57c-46fb-bf95-157df926afa8" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Attribution des empreintes physiques correspondant aux composants.
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/c2f14007-8ee4-48d3-a43c-2045063d54e4" alt="pcb" class="image-mean" />
            <p class = "txt_center">
            Verificaton des erreurs (DRC)
          </p>
          </div>

          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/d452cbd4-1514-47d7-be36-b994db5ffae6" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Organisation du PCB
            </p>
          </div>
          
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/14793231-34de-4975-bb9c-2c221a570426" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              D√©finition des contours du PCB (Edge Cuts)
            </p>
          </div>
            
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/7bf3e68c-8578-4ddb-849d-672ac3639993" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Plan de masse GND  
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/d20a6e74-2798-4ae9-a9ba-9a0280a9abcb" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Routage
            </p>
          </div>

          <div class="image-container">
            <p class = "txt_center">
              Visualisation 3D du PCB
            </p>
            <img src="https://github.com/user-attachments/assets/3e2ea849-39b4-47cb-a77e-ba3574701d50" alt="pcb" class="image-mean" />
          </div>
          <video controls width=auto>
            <source src="https://github.com/user-attachments/assets/c5784cd8-9c96-4c7d-97fa-074df501b6cc" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.                   
          </video>
        <p class="txt_center">
          <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/tree/main/Test2/Electronique/control_sation/controle%20station" target="_blank" class="download-link">lien vers les fichiers du pcb de la station de contr√¥le</a>
        </p>


    <h3 id="7-test2">7. Prototype</h3>
      <div class="image-container">
        <img src="images/Test2/Electronique/prototype0.png" alt="pcb" class="image-mean" />
      </div>

      <video controls width=auto>
        <source src="https://github.com/user-attachments/assets/31437a9f-915f-4c3a-84a9-cc7a7483c2a1" type="video/mp4">
        Votre navigateur ne supporte pas la vid√©o HTML5.                   
      </video>


      <div class="image-container">
        <img src="images/Test2/Electronique/prototype1.jpg" alt="pcb" class="image-mean" />
        <img src="images/Test2/Electronique/prototype2.jpg" alt="pcb" class="image-mean" />
      </div>

    </div>


        <div id="test3" class="subtab-content">
          <h2 id="projet3" class="projet-titre">Projet 3 - Afficheur 7 Segments √† Servomoteurs</h2>
            <h3 id="1-test3">1. Objectifs:</h3>
          <p>
            Cr√©er un afficheur 7 segments m√©canique utilisant **7 servomoteurs **, pilot√©s par un ATmega328P nu (sans carte Arduino), pour afficher les chiffres de 0 √† 9, puis de 9 √† 0. Le tout doit √™tre aliment√© par une batterie Li-ion, et le code doit √™tre non bloquant (sans delay()), avec un affichage toutes les secondes.
          </p>
          <p>
            Ce projet a pour objectif de :
          </p>
          <ul>
            <li>Comprendre le fonctionnement d‚Äôun capteur inertiel (IMU).</li>
            <li>afficher en temps r√©el les directions (haut, bas, gauche, droite) ainsi que les donn√©es d‚Äôacc√©l√©ration sur un √©cran LCD.</li>
            <li>Utiliser le protocole de communication I2C.</li>
            <li>Appliquer les bonnes pratiques de conception logicielle (structure modulaire, classes bien d√©finies, etc.).</li>
          </ul>

          <h3 id="2-test3">2. Cahier des charges</h3>
            <h4>Objectifs fonctionnels :</h4>
              <ul>
              <li>Cr√©er un afficheur 7 segments m√©canique utilisant <strong>des servomoteurs</strong>></li>
              <li>Contr√¥ler les servomoteurs avec un <strong>ATmega328P</strong></li>
              <li>G√©n√©rer un affichage fluide des chiffres de 0 √† 9 puis 9 √† 0, sans blocage</li>
              <li>Utiliser un signal PWM avec la biblioth√®que <strong>Servo.h</strong></li>
              <li>Concevoir un circuit imprim√© (PCB) optimis√© et compact</li>
              <li>Alimenter le syst√®me avec une batterie Li-ion via un <strong>r√©gulateur AMS1117</strong></li>
              </ul>
        
            <h4>Contraintes techniques :</h4>
              <ul>
              <li>Le syst√®me doit √™tre autonome (sans PC ni carte Arduino)</li>
              <li>Les segments doivent √™tre enti√®rement visibles m√©caniquement</li>
              <li>Aucun delay() ne doit √™tre utilis√© dans le code (gestion avec <strong>millis()</strong>)</li>
              <li>Le PCB doit int√©grer le r√©gulateur, le quartz, les r√©sistances et les condensateurs</li>
              <li>L‚Äôensemble doit √™tre test√© en simulation et en maquette avant production</li>
              </ul>

        <h3 id="3-test3">3. Architecture G√©n√©rale</h3>
          <h4>Mat√©riel Utilis√©:</h4>
              <ul>
              <li>Microcontr√¥leur: <strong>ATmega328P</strong></li>
              <li>Servomoteurs: <strong>SG90/Parallax</strong>(7)</li>
              <li>R√©gulateur: <strong>LM7805 5V</strong></li>
              <li>Quartz: <strong>16 MHz</strong></li>
              <li>Condensateurs: <strong>22pF</strong>(2)</li>
              <li>R√©sistance Pull-up: <strong>10kŒ© (reset)</strong></li>
              <li>Batterie Li-ion: <strong>3.7V</strong></li>
              <li>Veroboard</li>
              <li>Fils & connecteurs</li>
              </ul>

        <h3 id="4-test3">4. Fonctionnement global</h3>
          <p>
            Le principe de fonctionnement repose sur l‚Äôutilisation de 7 servomoteurs, chacun √©tant affect√© √† un segment de l‚Äôafficheur (de a √† g). Ces segments ne sont pas lumineux, mais d√©plac√©s m√©caniquement √† l‚Äôaide des bras des servomoteurs, ce qui cr√©e une repr√©sentation physique du chiffre souhait√©. Pour chaque chiffre (de 0 √† 9), une configuration particuli√®re des segments doit √™tre activ√©e ou d√©sactiv√©e. Cela signifie que certains servomoteurs se positionnent dans une position visible (par exemple 90¬∞ pour un segment ¬´ allum√© ¬ª) tandis que d‚Äôautres se r√©tractent (0¬∞ pour un segment ¬´ √©teint ¬ª). L‚Äôensemble est pilot√© par un microcontr√¥leur ATmega328P, qui g√©n√®re un signal PWM adapt√© √† chaque servo pour lui indiquer sa position. Le code est con√ßu pour √©viter toute fonction bloquante comme delay() ; les changements de chiffres sont g√©r√©s toutes les secondes √† l‚Äôaide de la fonction millis(), garantissant un comportement fluide et r√©actif du syst√®me. 
          </p>

        <h3 id="5-test3">5. Fonctionnement d√©taill√© du Servomoteur SG90</h3>
          <p>
            Un servomoteur est un moteur √©quip√© d‚Äôun r√©ducteur et d‚Äôun potentiom√®tre qui permet un contr√¥le pr√©cis de l‚Äôangle de rotation, g√©n√©ralement entre 0¬∞ et 180¬∞.
          </p>
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/0b8a4a6c-d0d1-4a34-965a-7431a619ccf9" alt="image" class="image-centree" />
          </div>

          <h4>Caract√©ristiques techniques du SG90</h4>
            <ul>
              <li>Dimensions: 22 x 11.5 x 27 mm</li>
              <li>Poids: 	9 g</li>
              <li>Tension d‚Äôalimentation: 4.8 V √† 6 V</li>
              <li>Vitesse: 0.12 s / 60¬∞</li>
              <li>Couple: 1.2 kg/cm</li>
              <li>Angle de rotation: 	0¬∞ √† 180¬∞</li>
            </ul>

            <h4>Signal PWM</h4>
            <p>
              Le servomoteur SG90 est command√© par un signal PWM (Pulse Width Modulation), qui est une suite d'impulsions r√©p√©t√©es p√©riodiquement. La largeur de l'impulsion (temps pendant lequel le signal est √† l'√©tat haut) d√©termine l'angle de positionnement du servomoteur.
            </p>
            <p>En g√©n√©ral :</p>
            <ul>
              <li>Une impulsion de 1 ms positionne l'axe √† 0¬∞ (gauche)</li>
              <li>Une impulsion de 1.5 ms positionne l'axe √† 90¬∞ (milieu)</li>
              <li>Une impulsion de 2 ms positionne l'axe √† 180¬∞ (droite)</li>
            </ul>
            <p>
              Ce signal est r√©p√©t√© <strong>toutes les 20 ms</strong>, soit une fr√©quence de 50 Hz. Le microcontr√¥leur doit maintenir cette fr√©quence et adapter la dur√©e de l'impulsion pour indiquer la position voulue. Si la fr√©quence est trop basse ou si le signal n‚Äôest pas stable, le servomoteur risque de vibrer ou de perdre sa position.
            </p>

            <div class="code-container">
            <p>Code_servo_basique.ino </p>
            <div class="btn-bar">
              <button onclick="copierCode('Code_servo_basique-ino', this)">üìã</button>
              <button onclick="telechargerCode('Code_servo_basique-ino', 'Code_servo_basique.ino', 'text/ino', this)">ü°á</button>
            </div>
            <pre><code id="Code_servo_basique-ino">
    // Test utilisation servomoteur SG90
    #include &lt;Servo.h&gt;
    Servo monservo; // Cr√©e l‚Äôobjet pour contr√¥ler le servomoteur

    void setup() {
      monservo.attach(9);     // Utilise la broche 9 pour le contr√¥le
      monservo.write(0);      // Positionne le servomoteur √† 0¬∞ (repos)
    }

    void loop() {
      // Boucle vide pour ce test
    }
            </code></pre>
            </div>

            <p>
            Ce code repr√©sente la toute premi√®re √©tape de l‚Äôutilisation d‚Äôun servomoteur. Il permet de l‚Äôattacher √† une broche num√©rique (ici D9) et de le positionner √† un angle pr√©cis (ici 0¬∞).
            Ce code utilise millis() pour g√©rer la temporisation, ce qui permet d'√©viter toute fonction bloquante comme delay().
            </p>
                
          <h3 id="6-test3">6. Utilisation de Deux Types de Servomoteurs (SG90 & Parallax)</h3>
            <p>
              Pendant le d√©veloppement, nous n‚Äôavons pas pu trouver 7 servomoteurs SG90 identiques. Pour contourner ce probl√®me, nous avons utilis√© une combinaison de servomoteurs SG90 et Parallax Continuous Rotation.
            </p>

            <h4>Adaptation du fonctionnement :</h4>
            <p>
              Les SG90 ont √©t√© utilis√©s normalement pour repr√©senter les segments ON/OFF via des angles pr√©cis.
              Les Parallax Continuous Rotation (rotation continue) ont √©t√© calibr√©s pour tourner bri√®vement dans un sens ou l‚Äôautre (ON ou OFF), puis s‚Äôarr√™ter.
            </p>

            <h4>Fonctionnement d√©taill√© du Servomoteur Parallax Continuous Rotation :</h4>
            <p>
              Ce type de servo ne peut pas se positionner √† un angle fixe. Il tourne dans un sens ou l‚Äôautre √† une certaine vitesse selon le signal PWM re√ßu.
            </p>

            <ul>
              <li>Caract√©ristiques techniques:</li>
              <ul>
                  <li>Type: Rotation continue</li>
                  <li>Tension: 4.8 ‚Äì 6 V</li>
                  <li>Signal neutre: 1500 ¬µs (arr√™t)</li>
                  <li>Vitesse max: ~60 tr/min</li>
                  <li>Contr√¥le: Par largeur d‚Äôimpulsion</li>
                  <li>Angle de positionnement: Non applicable</li>     
              </ul>
              <li>Signal de contr√¥le:</li>
              <ul>
                  <li>< 1500 ¬µs: Rotation sens horaire</li>
                  <li>> 1500 ¬µs: Rotation sens antihoraire</li>
                  <li>= 1500 ¬µs: Arr√™t (neutre)</li>    
              </ul>
              <li>Utilisation dans notre projet</li>
              <ul>
                  <li>ON: 1300 ¬µs pendant 200 m</li>
                  <li>OFF: 1700 ¬µs pendant 200 ms</li>
                  <li>Arr√™t: 1500 ¬µs</li>    
              </ul>
            </ul>
            <p>
              <strong>NB:</strong> Comme ces moteurs ne retournent pas √† une position fixe, chaque moteur a √©t√© calibr√© manuellement pour assurer l‚Äôalignement visuel des segments.
            </p>
      
          <h3 id="7-test3">7. Biblioth√®que n√©cessaire: <strong>Servo.h</strong></h3>  
            <p>
              La biblioth√®que <strong>Servo.h</strong> est une biblioth√®que native d'Arduino qui permet de contr√¥ler facilement les servomoteurs √† l‚Äôaide d‚Äôun signal PWM.
            </p>
            <p>Elle prend en charge :</p>
            <ul>
              <li>L‚Äôattachement d‚Äôun servomoteur √† une broche num√©rique via <strong>servo.attach(pin)</strong>;</li>
              <li>L‚Äôenvoi d‚Äôun angle de rotation avec <strong>servo.write(angle)</strong>;</li>
              <li>La gestion du signal PWM en arri√®re-plan sans que l‚Äôutilisateur ait √† le g√©n√©rer manuellement.</li>
            </ul>
            
            <p>
              Cette biblioth√®que est <strong>incluse par d√©faut</strong> avec l‚ÄôIDE Arduino. Aucun t√©l√©chargement suppl√©mentaire n‚Äôest n√©cessaire.
            </p>


          <h3 id="8-test3">8. Code Arduino (version multi-servos)</h3> 
            <p>
              Dans ce projet, le code Arduino est structur√© pour contr√¥ler 7 servomoteurs, chacun correspondant √† un segment (de a √† g) de l‚Äôafficheur 7 segments m√©canique.
            </p>
            <p>
              Voici les points cl√©s du code :
            </p>
            <ul>
              <li><strong>Utilisation de la biblioth√®que Servo.h</strong>:</li>
              <p>
                Cette biblioth√®que facilite le contr√¥le des servomoteurs en g√©n√©rant automatiquement le signal PWM n√©cessaire sur les broches num√©riques du microcontr√¥leur.
              </p>
              <li><strong>Cr√©ation de 7 objets Servo distincts</strong>: </li>
              <p>
                Chaque segment (a, b, c, d, e, f, g) est associ√© √† un objet Servo diff√©rent.
                Cela permet de commander individuellement chaque servomoteur en lui envoyant un angle sp√©cifique.
              </p>
              <li><strong>D√©finition d‚Äôun tableau chiffres[10][7]</strong>:</li>
              <p>
                Ce tableau contient la configuration des segments pour chaque chiffre de 0 √† 9.
              </p>
              <ul>
                <li>Chaque ligne du tableau correspond √† un chiffre.</li>
                <li>Chaque colonne correspond √† un segment (a √† g).</li>
                <li>La valeur 1 signifie que le segment doit √™tre activ√© (servo en position ¬´ ON ¬ª, par exemple 90¬∞).</li>
                <li>La valeur 0 signifie que le segment doit √™tre d√©sactiv√© (servo en position ¬´ OFF ¬ª, par exemple 0¬∞).</li>
              </ul>
              <p>
                Cela permet d‚Äôactiver ou d√©sactiver facilement les segments n√©cessaires pour afficher un chiffre donn√© en parcourant simplement ce tableau.
              </p>
              <li><strong>Gestion de la temporisation avec millis()</strong></li>
              <p>
                Pour que le programme reste r√©actif et √©vite les blocages, la fonction millis() est utilis√©e pour d√©clencher le changement de chiffre toutes les secondes.
              </p>
              <p>
                <strong>millis()</strong> retourne le nombre de millisecondes √©coul√©es depuis le d√©marrage du programme.
              </p>
              <p>
                En stockant la derni√®re valeur de millis() lors d‚Äôun changement, on peut comparer √† la valeur actuelle pour savoir quand une seconde s‚Äôest √©coul√©e sans utiliser delay().
              </p>
              <p>
                Cela permet au microcontr√¥leur de continuer √† g√©rer les servomoteurs et autres t√¢ches sans interruption ni blocage.
              </p>
            </ul>

            <div class="image-container">
              <img src="images/Test3/Electronique/tableau.png" alt="image" class="image-centree" />
              <p>
                Tableau logique des chiffres (Segments activ√©s)
              </p>
            </div>
            <p>
              Chaque ligne correspond √† un chiffre et chaque colonne (a‚Äìg) repr√©sente un segment :
            </p>


            <div class="code-container">
            <p>Code_servo_7seg.ino </p>
            <div class="btn-bar">
              <button onclick="copierCode('Code_servo_7seg-ino', this)">üìã</button>
              <button onclick="telechargerCode('Code_servo_7seg-ino', 'Code_servo_7seg.ino', 'text/ino', this)">ü°á</button>
            </div>
            <pre><code id="Code_servo_7seg-ino">
    #include &lt;Servo.h&gt;  // Inclusion de la biblioth√®que standard Servo

    // D√©finition des angles pour contr√¥ler les segments
    #define ANGLE_ON  0     // Angle correspondant √† un segment "allum√©"
    #define ANGLE_OFF 90    // Angle correspondant √† un segment "√©teint"

    // D√©claration du nombre total de segments (7 segments A √† G)
    const int NUM_SEGMENTS = 7;

    // Tableau des broches reli√©es aux servomoteurs pour les segments A √† G
    const int servoPins[NUM_SEGMENTS] = {2, 3, 4, 5, 6, 7, 8};

    // Tableau d‚Äôobjets Servo, un pour chaque segment
    Servo servos[NUM_SEGMENTS];

    // D√©finition de l‚Äô√©tat ON (0¬∞) ou OFF (90¬∞) pour chaque chiffre de 0 √† 9
    // Chaque ligne correspond √† un chiffre, chaque colonne √† un segment : A B C D E F G
    const bool digits[10][7] = {
      {0, 0, 0, 1, 1, 1, 1}, // 0
      {1, 0, 0, 0, 0, 0, 1}, // 1
      {0, 0, 1, 1, 1, 0, 0}, // 2
      {0, 0, 0, 1, 0, 0, 0}, // 3
      {1, 0, 0, 0, 0, 1, 0}, // 4
      {0, 1, 0, 1, 0, 1, 0}, // 5
      {0, 1, 0, 1, 1, 1, 0}, // 6
      {0, 0, 0, 0, 0, 0, 1}, // 7
      {0, 0, 0, 1, 1, 1, 0}, // 8
      {0, 0, 0, 1, 0, 1, 0}  // 9
    };

    // Variables pour g√©rer la temporisation sans bloquer le code
    unsigned long previousMillis = 0;         // M√©morise le temps du dernier changement
    const unsigned long interval = 1000;      // Intervalle entre les changements (1 seconde)

    // Variables pour suivre le chiffre actuel et la direction du comptage
    int digit = 0;        // Chiffre actuellement affich√©
    int direction = 1;    // 1 = incr√©menter, -1 = d√©cr√©menter

    // Fonction d'initialisation : attache chaque servo √† sa broche
    void setup() {
      for (int i = 0; i < NUM_SEGMENTS; i++) {
        servos[i].attach(servoPins[i]);  // Initialise chaque servo
      }

      displayDigit(digit);  // Affiche le premier chiffre (0)
    }

    // Boucle principale qui s‚Äôex√©cute en continu
    void loop() {
      unsigned long currentMillis = millis();  // Temps √©coul√© depuis le d√©marrage

      // Si une seconde s'est √©coul√©e, on change de chiffre
      if (currentMillis - previousMillis >= interval) {
        previousMillis = currentMillis;  // Met √† jour le temps du dernier changement

        digit += direction;  // Incr√©mente ou d√©cr√©mente le chiffre

        // Si on d√©passe 9, on repart dans l'autre sens (compte √† rebours)
        if (digit > 9) {
          digit = 9;
          direction = -1;
        }

        // Si on descend en dessous de 0, on repart vers le haut
        else if (digit < 0) {
          digit = 0;
          direction = 1;
        }

        // Affiche le chiffre actuel sur les servos
        displayDigit(digit);
      }
    }

    // Fonction qui positionne les servos en fonction du chiffre √† afficher
    void displayDigit(int d) {
      for (int i = 0; i < NUM_SEGMENTS; i++) {
        // Si la valeur est 0 ‚Üí servo √† ANGLE_ON (segment allum√©)
        // Si la valeur est 1 ‚Üí servo √† ANGLE_OFF (segment √©teint)
        servos[i].write(digits[d][i] ? ANGLE_ON : ANGLE_OFF);
      }
    }
              </code></pre>
            </div>


          <h3 id="9-test3">9. Test et D√©monstration</h3>
          <video controls width=auto>
            <source src="https://github.com/user-attachments/assets/130669d9-22cf-476d-a163-3bf61610d7c9" type="video/mp4">
            Votre navigateur ne supporte pas la vid√©o HTML5.
          </video>

          <h3 id="10-test3">10. Realisation du PCB</h3>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/0e23648c-f8ee-45c9-9850-5ba5f6db3ad8" alt="image" class="image-centree" />
              <p>
                Cr√©ation du sch√©ma √©lectronique
              </p>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/98b6fc98-13e5-4ba5-ab2b-7872c209b878" alt="image" class="image-centree" />
              <p>
                Footprints
              </p>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/a87adc71-6bbc-463b-8c03-43fbccf6e10f" alt="image" class="image-centree" />
              <p>
                Organisation du PCB
              </p>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/c9062dbf-42e9-4f3e-bfb0-2ad89b12f901" alt="image" class="image-centree" />
              <p>
                D√©finition des contours du PCB (Edge Cuts)
              </p>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/f97bfb1f-24de-4170-b13e-9195898db0dc" alt="image" class="image-centree" />
              <p>
                Routage
              </p>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/4f33d491-1f5b-4613-8751-e815a7be874e" alt="image" class="image-centree" />
              <p>
                Visualisation 3D du PCB
              </p>
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/e0e40ae5-1763-425d-8a55-42d6e8e38461 " type="video/mp4">
              Votre navigateur ne supporte pas la vid√©o HTML5.
            </video>

          <p class="txt_center">
            <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test3/Electronique/afficheur7segment.zip" download class="download-link">t√©l√©charger les fichiers PCB</a>
          </p>
          
        </div>

      </section>
    </main>
  </div>

  <footer>
    Copyright ¬© 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="script_commun.js"></script>
  <script src="script_code.js"></script>
</body>
</html>
