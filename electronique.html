<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="stylesheet" href="style-commun.css" />
  <link rel="stylesheet" href="style-code.css" />
  <title>Département Électronique – B2MS CleanTech</title>
</head>
<body>

    <header class="header">
        <div class="section__container header__container_domaine">
            <h2>Département Électronique</h2>
        </div>
        
    </header>
  
  <nav class="main-nav">
    <a href="index.html"><button>Accueil</button></a>
    <a href="it.html"><button>IT</button></a>
    <button class="tab-button active" data-target="electronique-content">Electronique</button>
    <a href="mecanique.html"><button>Mécanique</button></a>
    <a href="mecatronique.html"><button>Mécatronique</button></a>
  </nav>

  <section id="it-content" class="tab-content active">
    <nav class="subnav">
      <button class="subtab-button active" data-target="test1">Projet 1</button>
      <button class="subtab-button" data-target="test2">Projet 2</button>
      <button class="subtab-button" data-target="test3">Projet 3</button>
    </nav>

    <div id="test1" class="subtab-content active">
      <h2>Projet Gyroscope et Accéléromètre MPU6050</h2>
        <h3>1. Contexte et objectifs:</h3>
          <p>
            Les données de navigation telles que la direction et l'accélération sont essentielles dans la conception d’un robot.
            Ce projet utilise un module MPU6050, combinant un gyroscope et un accéléromètre, pour mesurer l’orientation et les mouvements.
          </p>
          <p>
            Ce projet a pour objectif de :
          </p>
          <ul>
            <li>Comprendre le fonctionnement d’un capteur inertiel (IMU).</li>
            <li>afficher en temps réel les directions (haut, bas, gauche, droite) ainsi que les données d’accélération sur un écran LCD.</li>
            <li>Utiliser le protocole de communication I2C.</li>
            <li>Appliquer les bonnes pratiques de conception logicielle (structure modulaire, classes bien définies, etc.).</li>
          </ul>

          <h3>2. Choix du capteur : MPU6050</h3>

          <p>
           Le <strong>MPU6050</strong> est un capteur IMU (Inertial Measurement Unit) 6 axes qui combine :
            <ul>
            <li>Un accéléromètre 3 axes</li>
            <li>Un gyroscope 3 axes</li>
            </ul>
          </p>
        
          <p>
            Il utilise une interface I2C, parfaitement compatible avec les
            microcontrôleurs comme l’Arduino, ce qui facilite la lecture des
            données avec un minimum de fils et une consommation réduite.
          </p>

          <p>
            Il est largement utilisé dans la communauté Arduino, avec de
            nombreuses bibliothèques disponibles (comme MPU6050.h ou
            Wire.h), ce qui simplifie le développement et le débogage
          </p>

          <p>
          <strong>Caractéristiques principales</strong> : <a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" download class="download-link">datasheet du MPU6050</a>
            <ul>
            <li>Interface I2C (adresse par défaut : `0x68`)</li>
            <li>Plage de mesure accéléromètre : ±2g, ±4g, ±8g, ±16g</li>
            <li>Tension d’alimentation : 3.3V – 5V</li>
            </ul>
            
          </p>
          

        <h3>3. Principe de fonctionnement</h3>
            <p>
             Le capteur MPU6050 combine deux fonctions principales : un accéléromètre et un gyroscope.
            L’accéléromètre permet de mesurer l’accélération linéaire sur les trois axes (X, Y, Z), ce qui
            permet de détecter les mouvements de la main vers le haut, le bas, la gauche, la droite, l’avant
            ou l’arrière. De son côté, le gyroscope mesure la vitesse angulaire sur ces mêmes axes, ce qui
            permet de connaître l’orientation de la main, comme une inclinaison ou une rotation.
          </p>

          <p>
           Pour transmettre les données au microcontrôleur, le MPU6050 utilise le protocole de
            communication I2C. Ce protocole est simple et efficace, car il ne nécessite que deux fils : la
            ligne SCL (pour l’horloge) et la ligne SDA (pour les données). Grâce à cette liaison, le
            microcontrôleur peut envoyer des commandes au capteur et lire ses valeurs en temps réel.
          </p>

          <p>
           Pour que le MPU6050 envoie les données, il ne suffit pas
          de simplement le connecter. Étant donné qu’on utilise
          une communication I2C, il faut suivre un protocole bien
          défini :
          </p>

          <h4>a. Envoi d’une commande au capteur</h4>
  
            <p>
            Avant de lire une donnée, l’Arduino doit envoyer l’adresse du registre souhaité. Cette adresse indique quel type de
              donnée on veut (accélération, vitesse angulaire)
            </p>

            <div class="image-container">
              <img src="images/Test1/Electronique/registre_electronique1.png" alt="Registre" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="images/Test1/Electronique/registre_electronique2.png" alt="Registre" class="image-centree" />
            </div>

          <h4>b.  Structure des données reçues</h4>

            <p>
              Chaque mesure (accélération ou rotation) est codée sur 16 bits (2 octets) :  
            </p>
              <ul>
              <li>8 bits MSB (poids fort)</li>
              <li>8 bits LSB (poids faible)</li>
            </ul> 
            <p>
              Les valeurs sont en complément à deux (signed integer), ce qui permet d'indiquer un sens positif ou négatif du mouvement. 
            </p>

          <h4>c. Conversion des données brutes</h4>
  
            <p>
            Pour exploiter les mesures, il faut les convertir en unités physiques :
            </p>
            <ul>
              <li> Accélération en g (gravité terrestre)</li>
              <li> Rotation en °/s (degrés par seconde)</li>
            </ul> 

            <div class="image-container">
              <img src="images/Test1/Electronique/converesion_electro1.png" alt="Conversion" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="images/Test1/Electronique/converesion_electro2.png" alt="Conversion" class="image-centree" />
            </div>

          
          <h3>4. Schéma électronique sous KICAD</h3>
          <div class="image-container">
            <img src="images/Test1/Electronique/schema_electro.png" alt="Schéma électronique sous KICAD" class="image-centree" />
          </div>

          <h3>
            5. Codage : 
          </h3> 
          <h4>a. Code 1: </h4> 
            <p>
              Ce code utilise la librairie MPU6050 sur Arduino IDE.
            </p>
  
            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code-ino')">Copier</button>
                <button onclick="telechargerCode('code-ino', 'code.ino', 'text/plain')">Télécharger</button>
              </div>

              <pre><code id="code-ino">
                  #include &lt;Wire.h&gt;               // Bibliothèque pour communication I2C
                  #include &lt;LiquidCrystal_I2C.h&gt;  // Bibliothèque pour écran LCD I2C
                  #include &lt;MPU6050.h&gt;            // Bibliothèque pour capteur MPU6050

                  // Initialisation écran LCD avec adresse I2C 0x27, 16 colonnes et 2 lignes
                  LiquidCrystal_I2C lcd(0x27, 16, 2);

                  // Création instance MPU6050
                  MPU6050 mpu;

                  // Variables pour stocker l'accélération en g (gravité)
                  float ax, ay, az;

                  // Norme totale de l'accélération (valeur absolue)
                  float accel_norm;

                  // Seuil d'accélération (en g) pour détecter un mouvement significatif
                  const float threshold = 0.2;

                  void setup() {
                    Serial.begin(9600);  // Initialisation communication série à 9600 bauds (pour debug éventuel)
                    Wire.begin();        // Initialisation bus I2C

                    lcd.init();          // Initialisation écran LCD
                    lcd.backlight();     // Allumer rétroéclairage LCD

                    // Initialisation MPU6050
                    mpu.initialize();

                    // Vérification de la connexion avec MPU6050
                    if (!mpu.testConnection()) {
                      lcd.print("MPU6050 error"); // Affiche erreur si capteur non détecté
                      while (1);                  // Bloque le programme ici (boucle infinie)
                    }

                    lcd.clear();
                    lcd.print("MPU6050 OK"); // Confirmation que capteur est prêt
                    delay(1000);
                    lcd.clear();
                  }

                  void loop() {
                    // Variables pour stocker les valeurs brutes (raw) lues depuis MPU6050
                    int16_t rawAx, rawAy, rawAz;

                    // Lecture des valeurs d'accélération brute sur 3 axes
                    mpu.getAcceleration(&rawAx, &rawAy, &rawAz);

                    // Conversion des valeurs brutes en unités g (gravité)
                    // Selon datasheet, la sensibilité est 16384 LSB/g en mode ±2g
                    ax = rawAx / 16384.0;
                    ay = rawAy / 16384.0;
                    az = rawAz / 16384.0;

                    // Calcul de la norme de l'accélération totale vectorielle
                    // sqrt(x² + y² + z²) -> donne l'intensité totale ressentie
                    accel_norm = sqrt(ax * ax + ay * ay + az * az);

                    // Détection de la direction dominante en fonction du seuil
                    String direction = "";    // Texte à afficher (direction détectée)
                    if (ax > threshold) { 
                      direction = "Gauche";   // Si acceleration sur axe X positive > seuil
                    }
                    else if (ax < -threshold) {
                      direction = "Droite";   // Si acceleration sur axe X négative < -seuil
                    }
                    else if (ay > threshold) {
                      direction = "Arriere";  // Si acceleration sur axe Y positive > seuil
                    }
                    else if (ay < -threshold) {
                      direction = "Avant";    // Si acceleration sur axe Y négative < -seuil
                    }
                    else if (az > threshold) {
                      direction = "Haut";      // Si acceleration sur axe Z positive > seuil
                    }
                    else if (az < -threshold) {
                      direction = "Bas";       // Si acceleration sur axe Z négative < -seuil
                    }
                    else {
                      direction = "Stable";    // Si aucune acceleration significative détectée
                    }
                  
                    // Affichage sur l'écran LCD
                    lcd.clear();              // Efface l'écran à chaque boucle
                    lcd.setCursor(0, 0);      // Position curseur ligne 0, colonne 0
                    lcd.print("Dir: ");       // Affiche label "Direction"
                    lcd.print(direction);     // Affiche la direction détectée

                    lcd.setCursor(0, 1);      // Position curseur ligne 1, colonne 0
                    lcd.print("Accel: ");     // Affiche label "Accélération"
                    lcd.print(accel_norm, 2); // Affiche la norme de l'accélération avec 2 décimales
                    lcd.print(" g");          // Affiche unité g (gravité)

                    delay(300);               // Pause de 300 ms avant prochaine lecture
                  }
              </code></pre>
              </div>


          <h4>b. Code 2: </h4> 
            <p>
              Ce code n'utilise pas la librairie MPU6050 sur Arduino IDE.
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code-ino')">Copier</button>
                <button onclick="telechargerCode('code-ino', 'code.ino', 'text/plain')">Télécharger</button>
              </div>
              <pre><code id="code-ino">
                #include &lt;Wire.h&gt;               // Bibliothèque pour la communication I2C
                #include &lt;LiquidCrystal_I2C.h&gt;      // Bibliothèque pour gérer l'écran LCD I2C

                const int MPU = 0x68;                // Adresse I2C du capteur MPU6050 (valeur par défaut)

                LiquidCrystal_I2C lcd(0x27, 16, 2); // Initialisation de l'écran LCD I2C (adresse 0x27, 16 colonnes, 2 lignes)

                // Variables pour stocker les données d'accélération
                float AccX, AccY, AccZ;
                // Variables pour stocker les données de gyroscope
                float GyroX, GyroY, GyroZ;

                // Angles calculés à partir de l'accéléromètre
                float accAngleX, accAngleY;
                // Angles calculés à partir du gyroscope (intégrés)
                float gyroAngleX, gyroAngleY, gyroAngleZ;

                // Angles fusionnés (roll, pitch, yaw)
                float roll, pitch, yaw;

                // Erreurs calculées lors de la calibration (offsets à enlever)
                float AccErrorX, AccErrorY, GyroErrorX, GyroErrorY, GyroErrorZ;

                // Variables pour gérer le temps écoulé entre deux mesures
                float elapsedTime, currentTime, previousTime;

                // Compteur utilisé pour la calibration
                int c = 0;

                void setup() {
                  Serial.begin(19200);         // Initialisation du port série à 19200 bauds pour debug
                  Wire.begin();                // Démarrage de la communication I2C

                  // Réveil du MPU6050 qui est en veille par défaut
                  Wire.beginTransmission(MPU); // Démarrer la transmission vers MPU
                  Wire.write(0x6B);            // Registre PWR_MGMT_1 (gestion alimentation)
                  Wire.write(0x00);            // Mettre à 0 pour sortir du mode veille
                  Wire.endTransmission(true);  // Fin de la transmission

                  // Initialisation de l'écran LCD
                  lcd.begin(16, 2);            // Définir taille LCD (16x2)
                  lcd.backlight();             // Activer rétroéclairage
                  lcd.setCursor(0, 0);         // Positionner curseur au début ligne 0
                  lcd.print("Initialisation..."); // Message de démarrage
                  delay(1000);                 // Pause d'1 seconde
                  lcd.clear();                 // Effacer écran

                  // Calibration automatique du capteur (calcul des erreurs à soustraire)
                  calculate_IMU_error();
                  delay(20);                   // Petite pause
                }

                void loop() {
                  // === Lecture des valeurs brutes de l'accéléromètre ===
                  Wire.beginTransmission(MPU);
                  Wire.write(0x3B);                    // Adresse du registre de début des données Accel
                  Wire.endTransmission(false);        // Garder la communication ouverte
                  Wire.requestFrom(MPU, 6, true);     // Lire 6 octets (2 par axe X,Y,Z)

                  // Conversion des données brutes en valeurs en g (gravité)
                  AccX = (Wire.read() << 8 | Wire.read()) / 16384.0; // Accélération X
                  AccY = (Wire.read() << 8 | Wire.read()) / 16384.0; // Accélération Y
                  AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0; // Accélération Z

                  // Calcul des angles d'inclinaison (roll, pitch) avec accéléromètre
                  accAngleX = (atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI) - AccErrorX;
                  accAngleY = (atan(-AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI) - AccErrorY;

                  // === Lecture des valeurs brutes du gyroscope ===
                  previousTime = currentTime;           // Sauvegarde du temps précédent
                  currentTime = millis();                // Temps actuel en ms
                  elapsedTime = (currentTime - previousTime) / 1000;  // Temps écoulé en secondes

                  Wire.beginTransmission(MPU);
                  Wire.write(0x43);                    // Adresse du registre de début des données Gyro
                  Wire.endTransmission(false);        // Garder la communication ouverte
                  Wire.requestFrom(MPU, 6, true);     // Lire 6 octets (2 par axe X,Y,Z)

                  // Conversion des données brutes en degrés/seconde
                  GyroX = (Wire.read() << 8 | Wire.read()) / 131.0;
                  GyroY = (Wire.read() << 8 | Wire.read()) / 131.0;
                  GyroZ = (Wire.read() << 8 | Wire.read()) / 131.0;

                  // Soustraction des erreurs calculées lors de la calibration
                  GyroX = GyroX - GyroErrorX;
                  GyroY = GyroY - GyroErrorY;
                  GyroZ = GyroZ - GyroErrorZ;

                  // Intégration des vitesses angulaires pour obtenir les angles
                  gyroAngleX += GyroX * elapsedTime;
                  gyroAngleY += GyroY * elapsedTime;
                  yaw += GyroZ * elapsedTime;

                  // Application d'un filtre complémentaire pour combiner accéléromètre et gyroscope
                  // On donne plus de poids au gyroscope (0.96) car plus précis sur court terme
                  // L'accéléromètre corrige la dérive du gyroscope sur le long terme (0.04)
                  roll = 0.96 * gyroAngleX + 0.04 * accAngleX;
                  pitch = 0.96 * gyroAngleY + 0.04 * accAngleY;

                  // === Détection simple de la direction du mouvement en fonction des angles ===
                  String direction = "haut"; // Valeur par défaut

                  if (roll < -40 ) direction = "Avant";
                  else if (roll < 80 && roll > 60) direction = "Arriere";
                  else if (pitch > 15) direction = "Droite";
                  else if (pitch < -15) direction = "Gauche";
                  else if (pitch > 30) direction = "Haut";
                  else if (pitch > 120 && roll > 100) direction = "Bas";

                  // === Affichage de la direction détectée sur l'écran LCD ===
                  lcd.clear();
                  lcd.setCursor(0, 0);
                  lcd.print("Direction:");
                  lcd.setCursor(0, 1);
                  lcd.print(direction);

                  // Affichage des angles pour debug sur moniteur série
                  Serial.print("Roll: "); Serial.print(roll);
                  Serial.print(" | Pitch: "); Serial.print(pitch);
                  Serial.print(" | Yaw: "); Serial.println(yaw);

                  delay(300); // Pause avant prochaine lecture
                }

                // === Fonction pour calibrer automatiquement le capteur au démarrage ===
                void calculate_IMU_error() {
                  // Calibration accéléromètre : moyenne des angles calculés sur plusieurs mesures
                  while (c < 200) {
                    Wire.beginTransmission(MPU);
                    Wire.write(0x3B);
                    Wire.endTransmission(false);
                    Wire.requestFrom(MPU, 6, true);

                    AccX = (Wire.read() << 8 | Wire.read()) / 16384.0;
                    AccY = (Wire.read() << 8 | Wire.read()) / 16384.0;
                    AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0;

                    // Calcul des angles roll et pitch à partir de l'accéléromètre
                    AccErrorX += atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI;
                    AccErrorY += atan(-AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI;

                    c++;
                  }
                  // Moyenne des erreurs calculées
                  AccErrorX /= 200;
                  AccErrorY /= 200;
                  c = 0; // Réinitialisation compteur

                  // Calibration gyroscope : moyenne des valeurs lues au repos
                  while (c < 200) {
                    Wire.beginTransmission(MPU);
                    Wire.write(0x43);
                    Wire.endTransmission(false);
                    Wire.requestFrom(MPU, 6, true);

                    GyroX = Wire.read() << 8 | Wire.read();
                    GyroY = Wire.read() << 8 | Wire.read();
                    GyroZ = Wire.read() << 8 | Wire.read();

                    GyroErrorX += GyroX / 131.0;
                    GyroErrorY += GyroY / 131.0;
                    GyroErrorZ += GyroZ / 131.0;

                    c++;
                  }
                  // Moyenne des erreurs gyroscopiques
                  GyroErrorX /= 200;
                  GyroErrorY /= 200;
                  GyroErrorZ /= 200;

                  // Affichage des résultats de calibration dans le moniteur série
                  Serial.println("Calibration Terminee:");
                  Serial.print("AccErrorX: "); Serial.println(AccErrorX);
                  Serial.print("AccErrorY: "); Serial.println(AccErrorY);
                  Serial.print("GyroErrorX: "); Serial.println(GyroErrorX);
                  Serial.print("GyroErrorY: "); Serial.println(GyroErrorY);
                  Serial.print("GyroErrorZ: "); Serial.println(GyroErrorZ);
                }
              </code></pre>

            </div>


          <h3>6. Conception d'un prototype et démonstration</h3>
          <!-- <ul>
              <li> 
                <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/tree/e5c868a970dbb57e96550918782e5e32cda997c2/images/Test1/Electronique" download class="download-link">lien vers les images</a>
             </li>
              <li>
                <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/tree/e5c868a970dbb57e96550918782e5e32cda997c2/videos/Test1/Electronique" download class="download-link">lien vers les vidéos</a>
              </li>
            </ul>  -->
          
          <div class="image-container">
            <img src="images/Test1/Electronique/electronique1.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique2.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique3.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique4.jpg" alt="Prototype" class="image-small" />
          </div>

          <video controls width=auto>
            <source src="videos/Test1/Electronique/final_trial.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vidéo HTML5.
          </video>

          <video controls width=auto>
            <source src="videos/Test1/Electronique/prototype.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vidéo HTML5.
          </video>

          <h3>7. Remarques</h3>
            <ul>
            <li>
              Pour des lectures plus stables et précises, il est possible d'intégrer
              un filtre complémentaire ou un filtre de Kalman.</li>
            <li>
              Ce projet constitue une excellente base pour des systèmes plus avancés,
              tels que les contrôleurs, les robots auto-équilibrés ou les plateformes de stabilisation.</li>
          </ul> 
          
    
        <h3>8. Conclusion</h3>
          <p>
            Ce projet nous a permis d’explorer l’intégration d’un capteur inertiel dans un système embarqué, ainsi que de mettre en œuvre la détection
            et l’affichage en temps réel des mouvements de la main.
          </p>
           
          <p>
            Le module MPU6050 s’est révélé être un outil efficace et accessible
            pour la détection de l’orientation et des mouvements.
          </p>

          <p>
            Grâce à sa compatibilité avec l’écosystème Arduino et à la disponibilité de bibliothèques
            dédiées, le MPU6050 peut être facilement intégré dans divers projets éducatifs ou de prototypage.
          </p>

          <p>
            L’affichage des directions détectées et des valeurs d’accélération sur un écran LCD 16x2
            offre une visualisation claire et pédagogique, idéale pour l’apprentissage des capteurs,
            de la programmation de microcontrôleurs et des interfaces homme-machine.
          </p>      
          
          <p>
            Au-delà de son intérêt pédagogique, ce système peut être étendu à des applications telles
            que le contrôle par gestes, la réalité virtuelle ou la robotique, avec la possibilité
            d’ajouter une communication Bluetooth ou Wi-Fi pour renforcer l’interactivité.
          </p>      


    </div>

    <div id="test2" class="subtab-content">
      <h2>Boîte noire</h2>
      
      <h3>1. Introduction</h3>
        <p>
          Dans les systèmes embarqués modernes, la collecte et l’analyse de données 
          en temps réel sont essentielles pour le suivi et la sécurité des équipements, 
          notamment dans des domaines critiques comme l’automobile, l’aviation ou le 
          ferroviaire. S’inspirant du fonctionnement des boîtes noires utilisées dans 
          ces industries, ce projet a pour objectif de concevoir un système embarqué 
          capable d’enregistrer et de transmettre en temps réel des données de mouvement 
          (vitesse et orientation) à l’aide d’un capteur inertiel. 
          Les informations sont ensuite visualisées sur une station de contrôle via 
          un écran LCD. Ce projet s’inscrit dans le cadre du Tekbot Robotics Challenge 
          et fait appel à plusieurs compétences majeures : programmation directe des 
          microcontrôleurs ATmega328P sans utiliser de carte Arduino, communication via 
          le protocole I2C, conception de circuits imprimés avec KiCAD, réalisation 
          d’un boîtier cubique de 7 cm, intégration matérielle sur veroboard ou PCB,
          ainsi que la conception d’une alimentation spécifique.
        </p>

        <h3>2. Cahier des charges</h3>
          <h4>a. Objectifs fonctionnels</h4>
            <ul>
              <li>Lire les données de vitesse et d’orientation à l’aide du MPU6050</li>
              <li>Utiliser le microcontrôleur ATmega328P sans carte Arduino</li>
              <li>Concevoir un circuit imprimé (PCB) et une alimentation autonome</li>
              <li>Transmettre les données à une station de contrôle via I2C</li>
              <li>Afficher les données sur un écran LCD en mode 4 bits</li>
            </ul>

          <h4>b. Contraintes techniques</h4>
            <ul>
              <li>Le cube doit mesurer 7x7x7 cm, avec une face ouverte pour voir le circuit</li>
              <li>Le microcontrôleur du cube agit en maître I2C</li>
              <li>Le microcontrôleur de la station agit en esclave I2C</li>
              <li>Alimentation externe obligatoire, hors du cube</li>
              <li>Schéma et PCB réalisés avec KiCad</li>
            </ul>
          <h4>c. Matériels utilisés</h4>
            <ul>
              <li>ATmega328P ×2 : <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">datasheet</a></li>
              <li>MPU6050 : <a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" target="_blank">datasheet</a></li>
              <li>LCD 16x2 (mode 4 bits) : <a href="https://www.gotronic.fr/pj2-sbc-lcd16x2-fr-1441.pdf?srsltid=AfmBOopmg8VyH8PQXxRcqE7GEvoyRwGRHeKVU9ZsKwGmKu13oZXhPhaJ" target="_blank">datasheet</a></li>
              <li>Alimentation</li>
            </ul>

        <h3>3. Schéma synoptique</h3>
        <p>
          Ce système embarqué est composé de deux unités :
          une <strong>boîte noire</strong> et une <strong>station de contrôle</strong>, 
          connectées via le bus I2C.
          La boîte noire comprend un capteur MPU6050 qui détecte les mouvements de la main 
          et envoie les données à un microcontrôleur ATmega328P configuré en maître. 
          Celui-ci traite les données et les transmet à la station de contrôle, 
          où un autre ATmega328P, configuré en esclave, les reçoit. 
          Les informations sont ensuite affichées sur un écran LCD.
          Chaque unité est alimentée séparément par une source de 5V.
        </p>
        <div class="image-container">
            <img src="https://github.com/user-attachments/assets/8b703337-a753-49e2-947b-a988aeb19c89" alt="Prototype"/>
        </div>

        <h3>4. Description fonctionnelle des différents blocs du système</h3>
          <h4>a. Bloc d’alimentation</h4>
            <ul>
              <li><strong>Fonction principale</strong></li>
            <p>
              Ce bloc a pour objectif de fournir une tension continue et stable de 5V nécessaire 
              au fonctionnement des différents composants électroniques du système, 
              notamment le capteur <strong>MPU6050</strong>, les <strong>microcontrôleurs ATmega328P</strong> et l'écran <strong>LCD</strong>.
            </p>

              <li><strong>Fonctionnement</strong></li>
            <p>
              On utilise trois batteries de Li-Ion 3,7V rechargeables montées en série pour obtenir environ 12V.
            </p>
            <p>
              Le <strong>régulateur L7805</strong> reçoit ce 12V en entrée (Vin) et fournit du 5V en sortie (Vout).
            </p>
            <p>
              Deux condensateurs (330nF <strong>à l’entrée</strong> et 100nF <strong>à la sortie</strong>) sont utilisés pour stabiliser la tension et filtrer les parasites:
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/690d4b70-85dd-4cbb-bff8-a1c31e7033fd" alt="schema"/>
            </div>
            <p>
               La simulation sur proteus : Les condensateurs de filtrage ont été omis dans ce schéma pour simplifier la représentation, bien qu’ils soient indispensables en pratique pour assurer la stabilité et réduire le bruit.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/a75470b7-4158-495d-adb8-76909df0c935" alt="schema"/>
            </div>

            <video controls width=auto>
              <source src="video/Test2/Electronique/test.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.                   
            </video>

            </ul>
          
          <h4>b. Bloc d’entrée(dans la boite noire)</h4>
          <p>
            Nous avons choisi le capteur MPU6050 parce qu’il intègre un accéléromètre et un gyroscope dans un seul composant. Cela permet de mesurer les mouvements et les rotations de la main avec précision. Il est facile à utiliser grâce au protocole I2C, et il fonctionne bien avec le microcontrôleur ATmega328P. En plus, il est peu coûteux et largement utilisé dans les projets embarqués. D’autres capteurs peuvent faire un travail similaire, comme le MPU9250 (qui ajoute un magnétomètre), le LSM6DS3 (plus récent et plus économe), ou le ADXL34
          </p>
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/2c989400-0c29-46dc-907c-dcd7208a431b" alt="schema"/>
          </div>

          <h4>c. Bloc de commande(dans la boite noire)</h4>
            <ul>
              <li><strong>Étape 1 : Prise en main du microcontrôleur ATmega328P</strong></li>
            <p>
              Avant de démarrer le système complet, l’équipe s’est d’abord focalisée sur le microcontrôleur ATmega328P. L’objectif était de comprendre pleinement sa structure interne, ses broches, ainsi que la manière de le configurer et de le simuler.
            </p>
            <p>
              Nous avons étudié ses principales caractéristiques et son brochage :
            </p>
            <ul>
              <li>Le format DIP à 28 broches, comme dans les cartes Arduino Uno</li>
              <li>Les broches d’E/S numériques D0 à D13, pour piloter des LED, relais, etc.</li>
              <li>Les entrées analogiques A0 à A5, pour la lecture de capteurs</li>
              <li>L’interface I2C via SDA (PC4) et SCL (PC5)</li>
              <li>La communication série UART via TX (PD1) et RX (PD0)</li>
              <li>Les broches d’alimentation : VCC, GND, AVCC, AREF</li>
              <li>La broche RESET, généralement tirée à l’état haut via une résistance</li>
              <li>Les broches XTAL1/XTAL2 pour le quartz (utilisé plus tard)</li>
            </ul>
            <p>
              Ces éléments nous ont permis de préparer une simulation fiable sous Proteus pour la suite du projet.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/62775b28-f4f7-42ed-b677-140ee88c7769" alt="schema"/>
            </div>


              <li><strong>Étape 2 : Simulation basique de l’ATmega328P dans Proteus</strong></li>
            <p>
              Après avoir étudié la configuration du microcontrôleur, nous avons réalisé une première simulation simple sous Proteus, afin de valider son fonctionnement dans un environnement simulé.
            </p>
            <p>
              À ce stade :
            </p>
            <ul>
              <li>Nous n'avons pas utilisé les connexions d’alimentation (VCC/AVCC) ni de quartz externe, car elles ne sont pas obligatoires pour les logiques simples dans Proteus.</li>
              <li>Nous nous sommes concentrés sur le comportement des broches dans un exemple réel.</li>
            </ul>
            <p>
              Scénario de simulation : Nous avons conçu un système simple dans lequel :
            </p>
            <ul>
              <li>Un bouton poussoir est connecté à une entrée numérique.</li>
              <li>Nous nous sommes concentrés sur le comportement des broches dans un exemple réel.Lorsqu’on appuie sur le bouton, l’ATmega active un relais via une sortie numérique.</li>
              <li>Ce relais commande une lampe LED 12V, simulant une charge réelle.</li>
            </ul>
            <p>
              Le code Arduino correspondant a été compilé dans l’IDE Arduino, puis le fichier .hex généré a été intégré dans Proteus pour tester le comportement du circuit.
            </p>     
            <video controls width=auto>
            <source src="https://github.com/user-attachments/assets/d1cc5dd5-9109-4822-be6e-245693643c00" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>

            <p>
              Observation :
            </p>
            <ul>
              <li>Lorsque le bouton est pressé, le relais s’active et allume la LED.</li>
              <li>Le comportement observé est conforme à la logique attendue et cohérente.</li>
            </ul>
          </ul>

            <h4>d. Bloc d’affichage de la station du controle</h4>
            <p>
              Pour l’affichage des données au niveau de la station de contrôle, nous avons opté pour un écran LCD équipé d’un module I2C. Ce choix permet de simplifier le montage électronique en réduisant considérablement le nombre de connexions nécessaires entre le microcontrôleur et l’écran. Grâce à cette interface, seules deux lignes (SDA et SCL) suffisent pour transmettre les informations, ce qui laisse davantage de broches disponibles pour d’autres composants. L’écran LCD I2C assure ainsi une lecture claire et en temps réel des données de vitesse et d’orientation envoyées par la boîte noire.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/29db70ec-851d-4a14-a918-5cb94e43d4d7" alt="schema"/>
            </div>
            
          <h4>e. La communication I2C</h4>
            <p>
              Ce document constitue une présentation détaillée et approfondie du protocole I2C (Inter-Integrated Circuit), qui est un standard de communication série synchrone très répandu dans l’électronique embarquée. Ce protocole facilite l’échange d’informations entre un ou plusieurs maîtres et plusieurs périphériques esclaves en utilisant seulement deux fils, simplifiant ainsi les connexions matérielles tout en assurant une communication fiable et efficace.
            </p>

            <ul>
              <li><strong>Principe de fonctionnement</strong></li>
            <p>
              <a href="https://fr.wikipedia.org/wiki/I2C" target="_blank">Protocole I2C</a> (Inter-Integrated Circuit), développé par Philips (aujourd’hui NXP) dans les années 1980, 
              est un standard mondial pour la communication série entre circuits intégrés, 
              surtout dans les systèmes embarqués. Il utilise un bus bidirectionnel à deux fils : SDA pour les données et SCL pour l’horloge, permettant à plusieurs périphériques de partager le même canal tout en gérant précisément l’accès.
              Contrairement à des protocoles comme SPI, I2C minimise le nombre de connexions nécessaires, ce qui simplifie le routage sur circuit imprimé et réduit les coûts. Ce protocole est largement utilisé dans des domaines variés : automobile, domotique, informatique, etc.
            </p>
            <p>
              L'I2C fonctionne selon un modèle <a href="https://www.ionos.fr/digitalguide/serveur/know-how/le-principe-master/slave/" target="_blank">maître-esclave</a>: un ou plusieurs maîtres contrôlent la communication, et les esclaves répondent aux requêtes. 
              Chaque communication commence par une condition <strong>Start</strong>, suivie de <strong>l’adresse de l’esclave</strong> et d’un bit de direction (lecture/écriture). Les données sont ensuite échangées octet par octet, chaque octet étant confirmé par un bit d’acquittement(ACK). 
              La communication se termine par une condition <strong>Stop</strong>, qui libère le bus.
            </p>
            <p>
              Techniquement, I2C utilise des lignes ouvertes (open-drain) : les dispositifs ne peuvent que tirer les lignes vers le bas, tandis que des résistances pull-up maintiennent le niveau haut par défaut. Cela évite les conflits, notamment en mode multi-maîtres.
              Enfin, I2C offre une grande flexibilité en termes de vitesse, du mode standard (100 kHz) au mode rapide (jusqu’à 3,4 MHz) et au-delà dans certaines variantes propriétaires.
            </p>
            
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/18f95ad8-0fa3-49cb-99ce-52408ff42054" alt="schema"/>
            </div>

            <li><strong>Prise de contrôle du bus</strong></li>
            <p>
              La prise de contrôle du bus par un maître débute par une condition Start (S), qui est un événement distinctif sur le bus. Cette condition correspond à une transition sur la ligne SDA de l’état haut à l’état bas, alors que la ligne SCL est maintenue à l’état haut. Cette séquence particulière est détectée par tous les périphériques connectés au bus, qui entrent alors en mode écoute, prêts à recevoir des données.
            </p>
            <p>
              La condition Start joue un rôle fondamental : elle marque l’exclusivité du maître sur le bus, ce qui évite les collisions ou l’interférence avec d’autres maîtres éventuels. Elle sert aussi de synchronisation initiale à la transmission de données, en assurant que tous les appareils sont synchronisés sur le début de la communication.
            </p>
            <p>
              Les résistances pull-up sur les lignes SDA et SCL maintiennent ces lignes à un état logique haut par défaut, garantissant ainsi que le bus est en repos quand aucune communication n’a lieu.
            </p>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/592b1e08-6f4c-4e0a-972b-d53158d6ed80" alt="schema" class="image-mean"/>
              <!-- <img src="https://github.com/user-attachments/assets/2eeeefcc-9f5b-47ae-8ac2-8a300c7d97c5" alt="schema" class="image-mean"/> -->
            </div>
            <div class="image-container">
              <!-- <img src="https://github.com/user-attachments/assets/592b1e08-6f4c-4e0a-972b-d53158d6ed80" alt="schema" class="image-mean"/> -->
              <img src="https://github.com/user-attachments/assets/2eeeefcc-9f5b-47ae-8ac2-8a300c7d97c5" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Transmission d'un octet</strong></li>
            <p>
              La transmission des données sur le bus I2C s’effectue par octets (8 bits). Chaque bit est transmis séquentiellement, en commençant par le bit le plus significatif (MSB).
            </p>
            <p>
              Le protocole impose que chaque bit soit placé sur la ligne SDA pendant que la ligne SCL est à l’état bas. Ensuite, la ligne SCL passe à l’état haut, moment où le récepteur lit la valeur présente sur la ligne SDA. Lorsque la ligne SCL redescend à l’état bas, l’émetteur peut placer le bit suivant sur SDA, et ainsi de suite.
            </p>
            <p>
              Après l’envoi des 8 bits d’un octet, la ligne SDA est libérée pendant le 9e cycle d’horloge. C’est alors au récepteur de signaler par un bit d’acquittement (ACK) s’il a correctement reçu l’octet, en tirant la ligne SDA à l’état bas. S’il ne tire pas SDA à zéro, un bit de non-acquittement (NACK) est détecté, ce qui indique que la communication doit être interrompue ou qu’une erreur s’est produite.
            </p>
            <p>
              Ce mécanisme d’<strong>ACK/NACK</strong> est crucial car il assure la fiabilité des transmissions, permettant au maître de savoir si l’esclave est disponible et prêt à recevoir ou envoyer des données.
            </p>

            <li><strong>Transmission d'une adresse</strong></li>
            <p>
              Après la condition Start, le maître envoie un octet d’adresse pour identifier l’esclave avec lequel il souhaite communiquer. L’adresse est généralement codée sur 7 bits, suivis d’un bit R/W indiquant si la transaction sera une lecture ou une écriture.
            </p>
            <p>
              Le protocole prévoit aussi une extension 10 bits pour les réseaux comportant un grand nombre de périphériques, mais cette extension est moins fréquemment utilisée.
            </p>
            <p>
              Tous les périphériques esclaves surveillent le bus et comparent l’adresse reçue avec leur propre adresse. Celui qui reconnaît son adresse répond alors par un bit ACK en tirant la ligne SDA à l’état bas pendant le 9e bit. Les autres esclaves restent silencieux jusqu’à la prochaine séquence.
            </p>
            <p>
              Cette étape est essentielle car elle garantit que seules les communications destinées à un périphérique spécifique sont traitées, évitant ainsi toute interférence entre plusieurs périphériques sur le même bus.
            </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/d0ee80b6-b169-4cd5-9149-25fd731a3583" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Écriture d'une donnée</strong></li>
            <p>
              Une fois l’adresse reconnue par l’esclave, la phase de transfert des données peut commencer. Le maître transmet alors les octets de données à l’esclave, chaque octet étant suivi d’un bit ACK envoyé par l’esclave pour confirmer la bonne réception.  
            </p>
            <p>
              Le protocole permet d’envoyer autant d’octets que nécessaire dans une même communication, ce qui permet des transferts efficaces et continus.
            </p>
            <p>
              Pour terminer la communication, le maître génère une condition Stop (P), qui correspond à une transition de la ligne SDA de l’état bas à l’état haut alors que la ligne SCL est haute. Cette séquence indique à tous les périphériques que la transmission est terminée et que le bus est libéré pour une autre communication.
            </p>
            <p>
              Il existe également une condition Restart, qui est une condition Start générée sans condition Stop préalable, permettant de chaîner plusieurs opérations sur le même bus sans interruption.
            </p>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/cd3818b4-20a3-4ab2-8ad2-63cb27b47d49" alt="schema" class="image-mean"/>
            </div>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/61143d18-67bd-4ae0-a9b4-aafa01f3786f" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Arbitration</strong></li>
            <p>
              Le protocole I2C est conçu pour supporter un mode multi-maîtres, où plusieurs maîtres peuvent tenter d’accéder au bus simultanément. Pour éviter les conflits, un mécanisme d’arbitrage est mis en place.
            </p>
            <p>
              Lorsqu’un maître commence à transmettre, il surveille la ligne SDA et la compare avec ce qu’il souhaite envoyer. Si un maître détecte que la ligne SDA est forcée à l’état bas par un autre maître alors qu’il tente de la maintenir haute, il comprend qu’il a perdu l’arbitrage et abandonne immédiatement la transmission, laissant le bus libre au maître dominant.
            </p>
            <p>
              Ce mécanisme garantit qu’aucune collision électrique ne se produit sur le bus et que seule une source transmet à un instant donné. C’est une des forces du protocole I2C, qui permet une coexistence harmonieuse de plusieurs maîtres sur un même bus.
            </p>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/2a51d266-e7b7-4805-9f25-3cc9b081af5d" alt="schema" class="image-mean"/>
            </div>

            <li><strong>Clock Stretching</strong></li>
            <p>
              Le clock stretching est une fonctionnalité du protocole I2C qui permet à un esclave de ralentir temporairement la communication lorsqu’il n’est pas prêt à envoyer ou recevoir des données. Cela se fait en gardant la ligne SCL à l’état bas (LOW), empêchant ainsi le maître de continuer à envoyer des impulsions d’horloge. Une fois que l’esclave est prêt, il libère la ligne SCL, permettant au maître de reprendre la transmission. Cette technique est utile, par exemple, lorsque le capteur a besoin de plus de temps pour traiter ou préparer les données. Le maître doit respecter cet étirement d’horloge pour éviter des erreurs de communication.
            </p>
            
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/3b85fa91-3ed1-4b41-8336-1256be15648b" alt="schema" class="image-mean"/>
            </div>

            </ul>

        <h4>f. Communication I2C entre MPU6050 et ATmega328P</h4>
            <p>
              Dans notre projet, le microcontrôleur ATmega328P communique avec le capteur MPU6050 à l’aide du protocole I2C. Ce protocole permet de transmettre les données d’accélération et de rotation via deux fils (SDA et SCL). Le MPU6050 agit comme esclave, et l’ATmega328P comme maître.
            </p>
            <ul>
              <li><strong>Fonctionnement de la liaison I2C</strong></li>
            <p>
              La connexion matérielle entre le MPU6050 et l’ATmega328P s’effectue via le protocole I2C (Inter-Integrated Circuit), qui utilise deux lignes de communication :
            </p>
            <ul>
              <li>SDA (Serial Data Line) : ligne bidirectionnelle pour l’échange des données, connectée à la broche PC4 de l’ATmega328P.</li>
              <li>SCL (Serial Clock Line) : ligne d’horloge générée par le maître, connectée à la broche PC5 de l’ATmega328P.</li>
            </ul>
            <p>
              Sur le bus I2C, le dispositif qui initie la communication est appelé maître, tandis que celui qui répond s’appelle esclave. Dans notre cas :
              L’ATmega328P joue le rôle de maître, c’est lui qui contrôle le bus, génère l’horloge, et initie les échanges.
              Le MPU6050 est l’esclave, il attend que le maître lui demande des données spécifiques.
              Le maître démarre la communication en envoyant une adresse unique correspondant à l’esclave (ici l’adresse I2C du MPU6050, généralement 0x68), suivie d’une commande indiquant quel registre ou donnée il souhaite lire.
              </p>
            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/6cea5b00-bb19-4816-af14-adf2e965201a" alt="schema"/>
            </div>


              <li><strong>Envoi des commandes et réception des données</strong></li>
            <p>
              La communication suit ce processus 
            </p>
            <ul>
              <li>Le maître (ATmega328P) commence par envoyer une commande au MPU6050, qui consiste à spécifier l’adresse du registre interne dont il souhaite lire la valeur. Par exemple, pour lire l’accélération sur l’axe X, il envoie l’adresse du registre ACCEL_XOUT_H.</li>
              <li>Cette commande est envoyée via le bus I2C sous forme d’une trame contenant l’adresse de l’esclave, suivie de l’adresse du registre ciblé.</li>
              <li>Une fois la commande reçue, le MPU6050 prépare la donnée correspondante et la transmet dès que le maître la demande.</li>
              <li>Le maître récupère alors la ou les valeurs envoyées par le capteur, généralement sur plusieurs octets, qu’il traite ensuite pour en extraire l’information de mouvement (accélération, rotation, température).</li>
            </ul>
            
          </ul>

      <h3>5. Etapes de validation avant PCB</h3>
          <h4>a. Étape 1 : Communication I2C entre deux Arduino (Test de base)</h4>
            <p>
              Afin de valider le fonctionnement de la communication I2C entre deux microcontrôleurs en utilisant un exemple simple : un bouton poussoir et une LED.
            </p>
            <p>
              Composants utilisés :
            </p>
            <ul>
              <li>2 cartes Arduino UNO</li>
              <li>1 bouton poussoir (sur le maître)</li>
              <li>1 LED (sur l’esclave)</li>
              <li>Câblage SDA/SCL entre les deux cartes</li>
            </ul>

            <p>
              Fonctionnement  :
            </p>
            <ul>
              <li>L’Arduino maître lit l’état d’un bouton poussoir connecté en entrée.</li>
              <li>Cet état (appuyé ou relâché) est transmis à l’Arduino esclave via le protocole I2C.</li>
              <li>L’esclave reçoit cette donnée et contrôle une LED : elle s’allume si le bouton est appuyé, s’éteint sinon.</li>
            </ul>

            <p>
              But de l'étape : 
            </p>
            <ul>
              <li>Apprendre à configurer le bus I2C (maître/esclave).</li>
              <li>Vérifier la synchronisation et la fiabilité de la communication.</li>
              <li>Observer une réponse simple à un signal I2C.</li>
            </ul>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/88f6527a-9f2b-40c0-a4ea-c1e3489a3cf6" alt="schema"/>
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/f24d194f-d3f9-40da-8c5a-b3b9a5e75ebc" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>
        
        <h4>b. Étape 2 : Remplacement par des modules réels (MPU6050 et LCD)</h4>
            <p>
              Pour simuler une application plus réaliste en utilisant des capteurs réels(MPU6050) et un afficheur(lCD), tout en gardant la communication I2C entre deux cartes.
            </p>
            <p>
              Composants utilisés :
            </p>
            <ul>
              <li>MPU6050 (capteur accéléromètre/gyroscope) sur le maître</li>
              <li>Écran LCD (type I2C 16x2) sur l’esclave</li>
              <li>Deux cartes Arduino</li>
            </ul>

            <p>
              Fonctionnement  :
            </p>
            <ul>
              <li>Le capteur MPU6050 collecte les données d’accélération et de rotation.</li>
              <li>Ces données sont lues par l’Arduino maître via I2C.</li>
              <li>Le maître envoie ensuite les valeurs traitées à l’esclave.</li>
              <li>L’Arduino esclave reçoit les données et les affiche sur le LCD.</li>
            </ul>

            <p>
              But de l'étape : 
            </p>
            <ul>
              <li>Remplacer des composants de test par des modules intelligents.</li>
              <li>Manipuler un capteur complexe avec acquisition de données.</li>
              <li>Gérer l'affichage distant d'informations, toujours via I2C.</li>
              <li>Approfondir le protocole I2C dans un cas concret (multi-esclaves potentiels, synchronisation).</li>
            </ul>

            <div class="image-container">
              <img src="https://github.com/user-attachments/assets/4bf55be3-fb1c-43e9-98be-2359a4609619" alt="schema"/>
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/1c67d0e5-90eb-4aa1-bebf-cd58e934528a" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>

        <h4>c. Étape 3 : Intégration avec ATmega328P (préparation au PCB)</h4>
            <p>
             Afin de remplacer la carte Arduino par le **microcontrôleur brut** (ATmega328P), et de simuler les conditions réelles d’un circuit imprimé.
            </p>
            <p>
              Composants utilisés :
            </p>
            <ul>
              <li>2× ATmega328P</li>
              <li>2× Quartz</li>
              <li>4× Condensateurs 22 pF</li>
              <li>1× MPU6050</li>
              <li>1× Écran LCD 16x2 avec interface I2C</li>
              <li>2× Boutons poussoirs</li>
              <li>2× Résistances 10 kΩ</li>
              <li>Fils de connexion (Dupont)</li>
              <li>Breadboard</li>
            </ul>

            <p>
              Fonctionnement  :
            </p>
            <ul>
              <li>L’ATmega328P est programmé avec le même code que celui utilisé sur une carte Arduino, à l’aide d’un programmateur externe (comme USBasp ou Arduino as ISP).</li>
              <li>Les deux ATmega328P communiquent via le protocole I2C :</li>
              <ul>
                <li>L’un joue le rôle de maître (elle collecte les données du MPU6050).</li>
                <li>L’autre joue le rôle d’esclave (elle affiche les données sur un écran LCD I2C).</li>
              </ul>
              <li>Les microcontrôleurs sont utilisés en mode "standalone" (hors carte de développement).</li>
              <li>Connectés sur breadboard avec :</li>
              <ul>
                <li>Un quartz et deux condensateurs 22 pF pour chaque ATMEGA328P pour générer l’horloge.</li>
                <li>Une alimentation 5V stable.</li>
                <li>Un bouton poussoir relié à la broche RESET de chaque ATmega.</li>
                <li>Une résistance de 10 kΩ connectée entre la broche RESET et VCC, pour garantir un redémarrage stable.</li>
              </ul>
            </ul>
            
            <p>
              But de l'étape : 
            </p>
            <ul>
              <li>S’assurer que le microcontrôleur fonctionne correctement en mode autonome.</li>
              <li>Tester la communication I2C dans les conditions matérielles réelles du futur PCB.</li>
              <li>Préparer l’intégration finale des composants sur un PCB personnalisé.</li>
            </ul>

            <div class="image-container">
              <img src="https://github-production-user-asset-6210df.s3.amazonaws.com/215927366/457011835-60ee4f9b-8e22-4bce-a59e-369cb7b13c1f.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250619%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250619T145330Z&X-Amz-Expires=300&X-Amz-Signature=d162c0993c215ea0a0799f3edb3868bd47548c3773ec9747b8ee027303135831&X-Amz-SignedHeaders=host" alt="schema" class="image-small"/>
            </div>

            <video controls width=auto>
              <source src="https://github.com/user-attachments/assets/9b0e3092-58c1-435a-8556-9573676f7728" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>


          <p>Code maitre: </p>
          <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code-ino')">Copier</button>
                <button onclick="telechargerCode('code-ino', 'code_maitre.ino', 'text/plain')">Télécharger</button>
              </div>
              <pre><code id="code-ino">
                  #include &lt;Wire.h&gt;        
                  #include &lt;MPU6050.h&gt;  

                  MPU6050 mpu;

                  float ax, ay, az;
                  const float threshold = 0.2;
                  String direction = "";

                  void setup() {
                    Serial.begin(9600);
                    Wire.begin();      // Maître
                    mpu.initialize();

                    if (!mpu.testConnection()) {
                      Serial.println("Erreur MPU6050");
                      while (1);
                    }

                    Serial.println("MPU6050 OK");
                  }

                  void loop() {
                    int16_t rawAx, rawAy, rawAz;
                    mpu.getAcceleration(&rawAx, &rawAy, &rawAz);

                    ax = rawAx / 16384.0;
                    ay = rawAy / 16384.0;
                    az = rawAz / 16384.0;

                    // Détection de direction
                    if (ax > threshold) direction = "Gauche";
                    else if (ax < -threshold) direction = "Droite";
                    else if (ay > threshold) direction = "Arriere";
                    else if (ay < -threshold) direction = "Avant";
                    else if (az > threshold) direction = "Haut";
                    else if (az < -threshold) direction = "Bas";
                    else direction = "Stable";

                    // Envoi vers esclave
                    Wire.beginTransmission(8);         // adresse esclave
                    Wire.write(direction.c_str());     // envoyer la direction comme texte
                    Wire.endTransmission();

                    Serial.print("Direction envoyée : ");
                    Serial.println(direction);

                    delay(300);
                  }                  
              
              </code></pre>
            </div>

          <p>Code esclave: </p>
          <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('code-ino')">Copier</button>
                <button onclick="telechargerCode('code-ino', 'code_esclave.ino', 'text/plain')">Télécharger</button>
              </div>
              <pre><code id="code-ino">
                  #include &lt;Wire.h&gt;               // Bibliothèque pour communication I2C
                  #include &lt;LiquidCrystal_I2C.h&gt;  // Bibliothèque pour écran LCD I2C
                  #include &lt;MPU6050.h&gt;  
                  
                  LiquidCrystal_I2C lcd(0x27, 16, 2);  // LCD I2C

                  String receivedDirection = "";

                  void setup() {
                    Wire.begin(8);  // Adresse de l'esclave
                    Wire.onReceive(receiveData);

                    lcd.init();
                    lcd.backlight();
                    lcd.setCursor(0, 0);
                    lcd.print("Pret a recevoir");
                  }

                  void loop() {
                    // Affiche la dernière direction reçue
                    lcd.setCursor(0, 0);
                    lcd.print("Dir:            "); // Nettoyer la ligne
                    lcd.setCursor(5, 0);
                    lcd.print(receivedDirection);
                    
                    delay(200);
                  }

                  void receiveData(int bytes) {
                    receivedDirection = ""; // réinitialiser

                    while (Wire.available()) {
                      char c = Wire.read();
                      receivedDirection += c;
                    }

                    Serial.print("Recu : ");
                    Serial.println(receivedDirection);
                  }
              
              </code></pre>
            </div>
             
        <h4>Pourquoi cette Démarche ?</h4>
        <p>
          La réalisation d’un PCB nécessite des choix précis de composants et un bon fonctionnement garanti en amont. Cette démarche par étapes nous a permis de :
        </p>
        <ul>
          <li>Identifier les erreurs éventuelles (bruit sur la ligne I2C, mauvais câblage, alimentation instable…).</li>
          <li>Tester progressivement les modules dans un environnement de développement.</li>
          <li>Réduire le risque d’erreur lors de la conception du PCB.</li>
          <li>Avoir une base fonctionnelle avant le passage à la fabrication.</li>
        </ul>
      

      <h3>6. Réalisation du PCB</h3>
        <h4>a. PCB de la boite noire</h4>
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/4daa371b-60f8-45ec-88ee-bb22b75d8ffa" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Conception du schéma intégrant le microcontrôleur ATmega328P, le capteur MPU-6050 et les connecteurs.
          </p>
        </div>
        
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/f9ea1c3f-b691-48d5-a4c3-829fab5aea9e" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Attribution des empreintes physiques correspondant aux composants.
          </p>
        </div>
     
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/c029f01b-0e0d-4864-b490-48a2cf801f62" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Verificaton des erreurs (DRC)
          </p>
        </div>
        
        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/64ee506b-c1e7-46de-824a-649cb73a8f54" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Ajustement de la disposition pour optimiser l’espace et faciliter le routage.
          </p>
        </div>

        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/968138f4-4dd2-4971-a71d-c887548e13d0" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Routage des pistes
          </p>
        </div>
        

        <div class="image-container">
          <img src="https://github.com/user-attachments/assets/32678869-7ea0-4449-a07f-74b8b4168ad1" alt="pcb" class="image-mean" />
          <p class = "txt_center">
            Définition des contours du PCB (Edge Cuts)
          </p>
        </div>

        <div class="image-container">
          <p class = "txt_center">
            Visualisation 3D du PCB
          </p>
          <img src="https://github.com/user-attachments/assets/0b16bd0a-1850-40e2-8e45-25d22ce4fcd2" alt="pcb" class="image-mean" />
        </div>
        <video controls width=auto>
          <source src="https://github.com/user-attachments/assets/f897ede6-44c2-42a2-96d0-31dc648d50c1" type="video/mp4">
          Votre navigateur ne supporte pas la vidéo HTML5.                   
        </video>

        <p class="txt_center">
          <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Code/tree/main/Test2/Electronique/boite_noire" target="_blank" class="download-link">lien vers les fichiers du pcb de la boite noire</a>
        </p>

      <h4>b. PCB de la station de contrôle</h4>
       
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/9f6d6881-972e-4cf5-aead-8e29ac9a7a28" alt="pcb" class="image-mean"/>
            <p class = "txt_center">
              Conception du schéma intégrant le microcontrôleur ATmega328P, le capteur MPU-6050 et les connecteurs.
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/f0cfca43-da82-427a-95cb-d35d16d0c2fa" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Anotation
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/281e78ea-b57c-46fb-bf95-157df926afa8" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Attribution des empreintes physiques correspondant aux composants.
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/c2f14007-8ee4-48d3-a43c-2045063d54e4" alt="pcb" class="image-mean" />
            <p class = "txt_center">
            Verificaton des erreurs (DRC)
          </p>
          </div>

          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/d452cbd4-1514-47d7-be36-b994db5ffae6" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Organisation du PCB
            </p>
          </div>
          
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/14793231-34de-4975-bb9c-2c221a570426" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Définition des contours du PCB (Edge Cuts)
            </p>
          </div>
            
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/7bf3e68c-8578-4ddb-849d-672ac3639993" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Plan de masse GND  
            </p>
          </div>
        
          <div class="image-container">
            <img src="https://github.com/user-attachments/assets/d20a6e74-2798-4ae9-a9ba-9a0280a9abcb" alt="pcb" class="image-mean" />
            <p class = "txt_center">
              Routage
            </p>
          </div>

          <div class="image-container">
            <p class = "txt_center">
              Visualisation 3D du PCB
            </p>
            <img src="https://github.com/user-attachments/assets/3e2ea849-39b4-47cb-a77e-ba3574701d50" alt="pcb" class="image-mean" />
          </div>
          <video controls width=auto>
            <source src="https://github.com/user-attachments/assets/c5784cd8-9c96-4c7d-97fa-074df501b6cc" type="video/mp4">
            Votre navigateur ne supporte pas la vidéo HTML5.                   
          </video>
        <p class="txt_center">
          <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Code/tree/main/Test2/Electronique/control_sation/controle%20station" target="_blank" class="download-link">lien vers les fichiers du pcb de la station de contrôle</a>
        </p>


    <h3>7. Prototype</h3>
      <div class="image-container">
        <img src="https://github-production-user-asset-6210df.s3.amazonaws.com/215927366/457017687-5823fe73-bb04-430a-80aa-2c55f7771197.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250619%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250619T154249Z&X-Amz-Expires=300&X-Amz-Signature=9d2aeb32963441293d411a158c9d8f229af75361e1668c830dae32df6873df0d&X-Amz-SignedHeaders=host" alt="pcb" class="image-mean" />
      </div>

      <video controls width=auto>
        <source src="https://github.com/user-attachments/assets/31437a9f-915f-4c3a-84a9-cc7a7483c2a1" type="video/mp4">
        Votre navigateur ne supporte pas la vidéo HTML5.                   
      </video>


      <div class="image-container">
        <img src="images/Test2/Electronique/prototype1.jpg" alt="pcb" class="image-mean" />
        <img src="images/Test2/Electronique/prototype2.jpg" alt="pcb" class="image-mean" />
      </div>


    </div>


    <div id="test3" class="subtab-content">
      <h2>Test 3</h2>
      <p>Contenu du Test 3 :</p>
    </div>
  </section>

  <footer>
    Copyright © 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script>
    // Onglets principaux (IT, Electronique, ...)
    document.querySelectorAll(".tab-button").forEach(button => {
      button.addEventListener("click", e => {
        document.querySelectorAll(".tab-button").forEach(btn => btn.classList.remove("active"));
        e.currentTarget.classList.add("active");

        // Afficher le contenu lié (ici, uniquement IT est en page unique)
        document.querySelectorAll(".tab-content").forEach(tc => tc.classList.remove("active"));

        const target = e.currentTarget.getAttribute("data-target");
        if (target) {
          document.getElementById(target).classList.add("active");
        }
      });
    });

    // Sous-onglets (Test 1, 2, 3)
    document.querySelectorAll(".subtab-button").forEach(button => {
      button.addEventListener("click", e => {
        const parent = e.currentTarget.closest(".tab-content");

        parent.querySelectorAll(".subtab-button").forEach(btn => btn.classList.remove("active"));
        e.currentTarget.classList.add("active");

        parent.querySelectorAll(".subtab-content").forEach(content => content.classList.remove("active"));
        const target = e.currentTarget.getAttribute("data-target");
        parent.querySelector("#" + target).classList.add("active");
      });
    });
  </script>
  <script src="script_code.js"></script>
</body>
</html>
