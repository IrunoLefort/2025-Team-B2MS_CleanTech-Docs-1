<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles/style-commun.css" />
  <link rel="stylesheet" href="styles/style-code.css" />
  <title>D√©partement IT ‚Äì B2MS CleanTech</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>D√©partement IT</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href="./" class="nav-link"><i class="fas fa-home"></i> Accueil</a>

        <div class="nav-section">
          <a href="./it" style="text-decoration: none;"><button class="tab-button active"><i class="fas fa-desktop"></i> IT</button> </a>       
          
          <div class="sub-links">
            <a href="./it-projet1" class="subtab-button active">Projet 1</a>

            <nav class="project-subnav active" id="subnav-test1">
              <a href="#1-test1">1. Contexte et objectifs</a>
              <a href="#2-test1">2. Architecture g√©n√©rale</a>
              <a href="#3-test1">3. Concept de POO utilis√©s</a>
              <a href="#4-test1">4. Diagramme UML</a>
              <a href="#5-test1">5. Tests r√©alis√©s</a>
              <a href="#6-test1">6. R√©sultats obtenus</a>
              <a href="#7-test1">7. Limites et perspectives</a>
              <a href="#8-test1">8. Conclusion</a>
            </nav>

            <a href="./it-projet2" class="subtab-button">Projet 2</a>
            <a href="./it-projet3" class="subtab-button">Projet 3</a>
          </div>
        </div>

        <a href="./electronique" class="nav-link"><i class="fas fa-microchip"></i> √âlectronique</a>
        <a href="./mecanique" class="nav-link"><i class="fas fa-cogs"></i> M√©canique</a>
        <a href="./convoyeur" class="nav-link"></i><i class="fas fa-robot"></i> Convoyeur</a>
      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section id="it-content" class="tab-content active">

        <div id="test1" class="subtab-content active">
          <h2 id="projet1" class="projet-titre">Projet 1 ‚Äì Gestion de Robots</h2>

          <h3 id="1-test1">1. Contexte et objectifs</h3>
            <p>
              L‚Äôobjectif de ce projet est de mettre en pratique les principes de la programmation orient√©e objet (POO) en C++ √† travers la conception d‚Äôun syst√®me de gestion de diff√©rents types de robots.
            </p>
            <p>
              Le syst√®me permet notamment de :
            </p>
            <ul>
              <li>Cr√©er plusieurs types de robots avec des comportements sp√©cifiques.</li>
              <li>Simuler leurs mouvements.</li>
              <li>Impl√©menter des fonctionnalit√©s g√©n√©riques : h√©ritage, polymorphisme, surcharge, encapsulation, etc.</li>
              <li>Appliquer les bonnes pratiques de conception logicielle (structure modulaire, classes bien d√©finies, etc.).</li>
            </ul>

          <h3 id="2-test1">2. Architecture g√©n√©rale</h3>
            <p>
              Le syst√®me est compos√© de trois classes principales, dont une classe m√®re : <strong>robot</strong>.
            </p>

            <h4><strong>a. robot</strong>(Classe m√®re)</h4>
            <p>
              Il s'agit d'une classe g√©n√©rique repr√©sentant un robot. Elle regroupe les attributs et comportements communs √† tous les types de robots.
            </p>

            <p>
              - Attributs principaux : ID du robot, Position 2D : coordonn√©es (x, y), √âtat : ON ou OFF
            </p>
            <p>
              - Fonctionnalit√©s : constructeurs / destructeurs, m√©thodes de d√©placement (virtuelles), calcul de la distance √† l‚Äôorigine, m√©thodes d‚Äôaffichage
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('robot-cpp', this)">üìã</button>
                <button onclick="telechargerCode('robot-cpp', 'robot.cpp', 'text/x-c++src', this)">ü°á</button>
              </div>
              <pre><code id="robot-cpp">
    #include "robot.hpp"

    robot::robot() : ID(0), position(0, 0), status(OFF) {}

    robot::robot(unsigned int Id, float x, float y) : ID(Id), position(x, y), status(ON) {}

    robot::robot(const robot &rhs)
        : ID(rhs.ID), position(rhs.position), status(rhs.status) {}

    robot &robot::operator=(const robot &rhs)
    {
        if (this != &rhs)
        {
            ID = rhs.ID;
            position = rhs.position;
            status = rhs.status;
        }
        return *this;
    }

    robot::~robot() {}

    float robot::distanceFromOrigin()
    {
        return std::sqrt(position.x * position.x + position.y * position.y);
    }

    vect2D robot::getPosition() const
    {
        return position;
    }

    void robot::setPosition(const vect2D &currentPosition)
    {
        position = currentPosition;
    }

    unsigned int robot::getID() const
    {
        return ID;
    }

    void robot::setID(int Id)
    {
        ID = Id;
    }

    state robot::getStatus() const
    {
        return status;
    }

    void robot::setStatus(const state &OnOrOff)
    {
        status = OnOrOff;
    }

    void printNameOfRobot(robot *p)
    {
        std::cout << p->getNameOfRobot() << std::endl;
    }

    void moveRobot(robot *p)
    {
        p->move();
    }

              </code></pre>
            </div>

            <h4><strong>b. deliveryRobot </strong>(Classe fille)</h4>
            <p>
              Il s'agit d'un robot de livraison, d√©riv√© de <strong>robot</strong>.
            </p>

            <p>
              - Fonctionnalit√©s sp√©cifiques  : livrer des entit√©s vers des zones pr√©d√©finies (zone1, zone2), g√®rer le nombre d'entit√©s √† livrer, impl√©menter un d√©placement bas√© sur la zone          
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('deliveryRobot-cpp', this)">üìã</button>
                <button onclick="telechargerCode('deliveryRobot-cpp', 'deliveryRobot.cpp', 'text/x-c++src', this)">ü°á</button>
              </div>
              <pre><code id="deliveryRobot-cpp">
    #include "deliveryRobot.hpp"

    deliveryRobot::deliveryRobot(zone ZONE, unsigned short nbrOfEntities, unsigned int Id, float x, float y)
        : robot(Id, x, y), entities(nbrOfEntities), Zone(ZONE) {}

    deliveryRobot::deliveryRobot() : robot(), entities(0), Zone(keepYourPlace) {}

    deliveryRobot::deliveryRobot(const deliveryRobot &rhs) : robot(rhs)
    {
        if (this != &rhs)
        {
            entities = rhs.entities;
            Zone = rhs.Zone;
        }
    }

    deliveryRobot &deliveryRobot::operator=(const deliveryRobot &rhs)
    {
        if (this != &rhs)
        {
            robot::operator=(rhs);
            entities = rhs.entities;
            Zone = rhs.Zone;
        }
        return *this;
    }

    deliveryRobot::~deliveryRobot() {}

    void deliveryRobot::move()
    {
        switch (Zone)
        {
        case keepYourPlace:
            break;
        case zone1:
            position.x = 10;
            position.y = 20;
            if (entities > 0)
                entities--;
            break;
        case zone2:
            position.x = 0;
            position.y = 30;
            if (entities > 0)
                entities--;
            break;
        default:
            Zone = keepYourPlace;
            break;
        }
    }

    std::string deliveryRobot::getNameOfRobot()
    {
        return "Delivery Robot";
    }

    unsigned short deliveryRobot::getNbrOfEntities()
    {
        return entities;
    }

    void deliveryRobot::setNbrOfEntities(unsigned short nbrOfEntities)
    {
        entities = nbrOfEntities;
    }

    zone deliveryRobot::getZone()
    {
        return Zone;
    }

    void deliveryRobot::setZone(zone ZONE)
    {
        Zone = ZONE;
    }
              </code></pre>
            </div>

            <h4><strong>c. travellingRobot </strong>(Classe fille)</h4>
            <p>
              Il s'agit d'un robot qui se d√©place librement, d√©riv√© de <strong>robot</strong>.
            </p>

            <p>
              - Fonctionnalit√© sp√©cifique  : se d√©placer dans une direction donn√©e(avant, arri√®re, gauche, droite)       
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('travellingRobot-cpp', this)">üìã</button>
                <button onclick="telechargerCode('travellingRobot-cpp', 'travellingRobot.cpp', 'text/x-c++src', this)">ü°á</button>
              </div>
              <pre><code id="travellingRobot-cpp">
    #include "travellingRobot.hpp"

    travellingRobot::travellingRobot(direction DIRECTION, unsigned int Id, float x, float y)
        : robot(Id, x, y), Direction(DIRECTION) {}

    travellingRobot::travellingRobot() : robot(), Direction(Stop) {}

    travellingRobot::travellingRobot(const travellingRobot &rhs) : robot(rhs)
    {
        if (this != &rhs)
        {
            Direction = rhs.Direction;
        }
    }

    travellingRobot &travellingRobot::operator=(const travellingRobot &rhs)
    {
        if (this != &rhs)
        {
            robot::operator=(rhs);
            Direction = rhs.Direction;
        }
        return *this;
    }

    travellingRobot::~travellingRobot() {}

    void travellingRobot::move()
    {
        switch (Direction)
        {
        case Stop:
            break;
        case Forward:
            position.y += 1;
            break;
        case Backward:
            position.y -= 1;
            break;
        case Right:
            position.x += 1;
            break;
        case Left:
            position.x -= 1;
            break;
        default:
            Direction = Stop;
            break;
        }
    }

    std::string travellingRobot::getNameOfRobot()
    {
        return "Travelling Robot";
    }

    direction travellingRobot::getDirection()
    {
        return Direction;
    }

    void travellingRobot::setDirection(direction DIRECTION)
    {
        Direction = DIRECTION;
    }
              </code></pre>
            </div>

            <h4><strong>d. armRobot </strong>(Classe fille)</h4>
            <p>
              Il s'agit d'un bras robotique, d√©riv√© de <strong>robot</strong>.
            </p>

            <p>
              - Fonctionnalit√© sp√©cifique  : effectuer une rotation dans une direction     
            </p>

            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('armRobot-cpp', this)">üìã</button>
                <button onclick="telechargerCode('armRobot-cpp', 'armRobot.cpp', 'text/x-c++src', this)">ü°á</button>
              </div>
              <pre><code id="armRobot-cpp">
    #include "armRobot.hpp"

    armRobot::armRobot()
      : robot(), angle(0), rotationalDirection(Clockwise) {}

    armRobot::armRobot(rotate rotationalDirection, unsigned short initAngle, unsigned int id, float x, float y)
      : robot(id, x, y), angle(initAngle), rotationalDirection(rotationalDirection) {}

    armRobot::armRobot(const armRobot &rhs)
      : robot(rhs), angle(rhs.angle), rotationalDirection(rhs.rotationalDirection) {}

    armRobot &armRobot::operator=(const armRobot &rhs)
    {
      if (this != &rhs)
      {
        robot::operator=(rhs);
        angle = rhs.angle;
        rotationalDirection = rhs.rotationalDirection;
      }
      return *this;
    }

    armRobot::~armRobot() {}

    void armRobot::move()
    {
      // Simuler un mouvement de rotation de 10 degr√©s
      if (rotationalDirection == Clockwise)
        angle = (angle + 10) % 360;
      else
        angle = (angle + 350) % 360; // recule de 10 degr√©s
    }

    std::string armRobot::getNameOfRobot()
    {
      return "Arm Robot";
    }

    unsigned short armRobot::getAngle() const
    {
      return angle;
    }

    void armRobot::setAngle(unsigned short angle_)
    {
      angle = angle_;
    }

    rotate armRobot::getRotationalDirection() const
    {
      return rotationalDirection;
    }

    void armRobot::setRotationalDirection(rotate rotationalDirection_)
    {
      rotationalDirection = rotationalDirection_;
    }
              </code></pre>
            </div>
            
          <h3 id="3-test1">3. Concept de POO utilis√©s</h3>
          <ul>
            <li><strong>Encapsulation</strong> : Attributs priv√©s, acc√®s par getters/setters</li>
            <li><strong>H√©ritage </strong> : Les classes deliveryRobot et travellingRobot h√©ritent de robot</li>
            <li><strong>Polymorphisme </strong> : M√©thodes virtuelles (move, getNameOfRobot)</li>
            <li><strong>Surcharge </strong> : Constructeurs et op√©rateurs d‚Äôaffectation</li>
          </ul>

          <h3 id="4-test1">4. Diagramme UML</h3>
          <div class="image-container">
            <img src="images/Test1/IT/UML digramme.webp" alt="Diagramme UML simplifi√©" class="image-centree" />
          </div>

          <h3 id="5-test1">5. Tests r√©alis√©s</h3>
            <ul>
              <li>Cr√©ation d‚Äôobjets de chaque classe</li>
              <li>Simulation des d√©placements (changement de zone / direction)</li>
              <li>V√©rification des distances depuis l‚Äôorigine</li>
              <li>Test du polymorphisme avec des pointeurs de type robot*</li>
            </ul>  
            <div class="code-container">
              <div class="btn-bar">
                <button onclick="copierCode('main-cpp', this)">üìã</button>
                <button onclick="telechargerCode('main-cpp', 'main.cpp', 'text/x-c++src', this)">ü°á</button>
              </div>
              <pre><code id="main-cpp">
    #include "travellingRobot.hpp"
    #include "deliveryRobot.hpp"
    #include "armRobot.hpp"
    #include &lt;iostream&gt;

    std::string rotateToString(rotate r)
    {
        switch (r)
        {
        case anticlockwise:
            return "Anticlockwise";
        case Clockwise:
            return "Clockwise";
        default:
            return "Unknown";
        }
    }

    int main()
    {
        // ------------------Travelling Robot----------------------
        travellingRobot a(Forward, 111, 0, 0);
        printNameOfRobot(&a);
        moveRobot(&a);
        vect2D v = a.getPosition();
        std::cout << "\n"
                  << v.x << " " << v.y << std::endl;
        std::cout << a.getID() << std::endl;
        std::cout << a.getDirection() << std::endl;

        // ------------------Delivery Robot-----------------------
        deliveryRobot b(zone1, 10, 222, 0, 0);
        printNameOfRobot(&b);
        moveRobot(&b);
        v = b.getPosition();
        std::cout << "\n"
                  << v.x << " " << v.y << std::endl;
        std::cout << b.getID() << std::endl;
        std::cout << b.getNbrOfEntities() << std::endl;
        std::cout << b.getZone() << std::endl;

        // ------------------ARM Robot---------------------------
        armRobot c(anticlockwise, 0, 333, 0, 0);
        printNameOfRobot(&c);
        moveRobot(&c);
        v = c.getPosition();
        std::cout << "\n"
                  << v.x << " " << v.y << std::endl;
        std::cout << c.getID() << std::endl;
        std::cout << c.getAngle() << std::endl;
        std::cout << rotateToString(c.getRotationalDirection()) << std::endl;

        return 0;
    }
              </code></pre>
            </div>

          <h3 id="6-test1">6. R√©sultats obtenus</h3>
          <ul>
            <li>Chaque type de robot fonctionne ind√©pendamment</li>
            <li>Les mouvements sont simul√©s correctement selon la logique m√©tier</li>
            <li>Le code est bien structur√©, modulaire, r√©utilisable et extensible</li>
            <li>Les bonnes pratiques C++ sont respect√©es (gestion m√©moire, encapsulation, etc.)</li>
          </ul> 

          <h3 id="7-test1">7. Limites et perspectives</h3>
          <h4>Limitations :</h4>
          <ul>
            <li>Les d√©placements sont simul√©s mais pas visualis√©s graphiquement.</li>
            <li>Le syst√®me ne g√®re pas d‚Äôenvironnement r√©el ou physique</li>
          </ul> 
          <h4>Am√©liorations possibles :</h4>
          <ul>
            <li>Ajout d‚Äôune interface graphique (SFML, Qt)</li>
            <li>Impl√©mentation de logs ou de fichiers de tracking</li>
            <li>Extension √† d‚Äôautres types de robots (volants, marins, etc.)</li>
            <li>Gestion d‚Äôobstacles, de cartes ou de missions</li>
          </ul> 

          <h3 id="8-test1">8. Conclusion</h3>
          <p>
            Ce projet nous a permis de :
          </p>
          <ul>
            <li>Appliquer les concepts fondamentaux de la programmation orient√©e objet</li>
            <li>Comprendre l‚Äôimportance de la conception logicielle modulaire</li>
            <li>D√©velopper un syst√®me coh√©rent, √©volutif et structur√© en C++</li>
          </ul>  
          <p>
            Il constitue une base solide pour des projets plus complexes, comme des syst√®mes embarqu√©s dans des robots r√©els ou des simulations d‚Äôintelligence artificielle mobile.
          </p>
        </div>
      </section>
    </main>
  </div>

  <footer>
    Copyright ¬© 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="scripts/script_commun.js"></script>
  <script src="scripts/script_code.js"></script>
</body>
</html>
