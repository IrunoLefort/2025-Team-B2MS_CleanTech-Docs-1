# üìÑ Documentation du Projet ‚Äì Syst√®me de Gestion de Robots

## üë§ Team-B2MS_CleanTec

## üß† 1. Contexte et Objectif du Projet

L‚Äôobjectif de ce projet est de mettre en pratique les principes de la programmation orient√©e objet (POO) en C++ √† travers la conception d‚Äôun syst√®me de gestion de diff√©rents types de robots.

Ce syst√®me permet de :

- Cr√©er plusieurs types de robots avec des comportements sp√©cifiques.
- Simuler leurs mouvements.
- Impl√©menter des fonctionnalit√©s g√©n√©riques (h√©ritage, polymorphisme, surcharge, encapsulation, etc.).
- Appliquer les bonnes pratiques de conception logicielle.

---

## ‚öôÔ∏è 2. Architecture G√©n√©rale du Projet

Le syst√®me est compos√© de **quatre classes principales** :

### a. `robot` (classe m√®re)
Classe g√©n√©rique repr√©sentant un robot.

**Attributs** :
- ID du robot
- Position 2D (x, y)
- √âtat (ON / OFF)

**Fonctionnalit√©s principales** :
- Constructeurs / destructeurs
- M√©thodes de d√©placement (virtuelles pures)
- Calcul de la distance √† l‚Äôorigine
- M√©thodes d‚Äôaffichage (nom, ID)

---

### b. `deliveryRobot` (classe fille)
Robot de livraison, d√©riv√© de `robot`.

**Fonctionnalit√©s sp√©cifiques** :
- Livraison d'entit√©s vers des zones pr√©d√©finies (`zone1`, `zone2`)
- Gestion du nombre d'entit√©s √† livrer
- D√©placement automatique selon la zone

---

### c. `travellingRobot` (classe fille)
Robot de d√©placement libre, d√©riv√© de `robot`.

**Fonctionnalit√©s sp√©cifiques** :
- Se d√©place dans une direction donn√©e (`avant`, `arri√®re`, `gauche`, `droite`)
- Direction modifiable dynamiquement

---

### d. `armRobot` (nouvelle classe fille)
Robot √† un degr√© de libert√©, d√©riv√© de `robot`.

**Fonctionnalit√©s sp√©cifiques** :
- Ne se d√©place pas dans l‚Äôespace
- Effectue une rotation de son bras dans une direction (`clockwise`, `anticlockwise`)
- Angle modifiable dynamiquement

---

## üß± 3. D√©tails de l‚ÄôImpl√©mentation

### a. Fichiers du projet

| Fichier                         | R√¥le                                                   |
|--------------------------------|---------------------------------------------------------|
| `robot.hpp / robot.cpp`        | Classe de base `robot`                                 |
| `deliveryRobot.hpp / .cpp`     | Classe `deliveryRobot`                                 |
| `travellingRobot.hpp / .cpp`   | Classe `travellingRobot`                               |
| `armRobot.hpp / .cpp`          | Classe `armRobot`                                      |
| `main.cpp`                     | Fichier principal de test                              |
| `vect2D.hpp`                   | Structure repr√©sentant une position (x, y)             |
| `enums.hpp`                    | Enum√©rations des √©tats, zones, directions, rotations   |

---

### b. Concepts de POO utilis√©s

- ‚úÖ **Encapsulation** : Attributs priv√©s, getters/setters.
- ‚úÖ **H√©ritage** : Les classes filles h√©ritent de `robot`.
- ‚úÖ **Polymorphisme** : Surcharge des m√©thodes virtuelles (`move()`, `getNameOfRobot()`).
- ‚úÖ **Surcharge** : Surcharge des constructeurs et op√©rateurs d‚Äôaffectation.

---

## üìê 4. Diagramme UML Simplifi√©


![WhatsApp Image 2025-06-12 √† 17 12 55_9bec65ae](https://github.com/user-attachments/assets/9f2ddd81-a3cf-40c8-962b-950bc6706b68)

---


---

## üß™ 5. Tests R√©alis√©s

- Cr√©ation d‚Äôobjets de chaque classe.
- Simulation des d√©placements (zones ou direction).
- Rotation du bras pour `armRobot`.
- V√©rification des distances depuis l‚Äôorigine.
- Test du polymorphisme avec des pointeurs de type `robot*`.

---

## üí° 6. R√©sultats Obtenus

- Chaque type de robot fonctionne ind√©pendamment.
- Les mouvements sont simul√©s correctement selon la logique m√©tier.
- Le code est bien structur√©, modulaire, r√©utilisable et extensible.
- Les bonnes pratiques C++ sont respect√©es (encapsulation, initialisation, gestion m√©moire).

---

## üß© 7. Limites et Perspectives

### Limitations actuelles :

- D√©placements simul√©s uniquement (pas d'affichage graphique).
- Syst√®me non int√©gr√© √† un environnement r√©el ou embarqu√©.

### Am√©liorations possibles :

- Ajout d‚Äôune interface graphique (SFML, Qt...).
- Enregistrement des logs de d√©placement.
- Int√©gration √† des cartes ou gestion d‚Äôobstacles.
- Extension √† d‚Äôautres types de robots (volants, marins, collaboratifs...).

---

## ‚úÖ 8. Conclusion

Ce projet nous a permis de :

- Appliquer les concepts fondamentaux de la programmation orient√©e objet.
- Comprendre l‚Äôimportance de la conception logicielle modulaire et √©volutive.
- D√©velopper un syst√®me complet et structur√© en C++.

Il constitue une base solide pour des projets plus complexes, notamment dans les domaines de la robotique embarqu√©e ou de la simulation.

---

## üìÅ 9. Annexes

### a. Contenu du projet :
- `robot.hpp / robot.cpp`
- `deliveryRobot.hpp / deliveryRobot.cpp`
- `travellingRobot.hpp / travellingRobot.cpp`
- `armRobot.hpp / armRobot.cpp`
- `main.cpp` (facultatif pour la d√©monstration)
- `enums.hpp`
- `vect2D.hpp`

