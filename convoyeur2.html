<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"
    />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles/style-commun.css" />
  <link rel="stylesheet" href="styles/style-code.css" />
  <title>Système de convoyeur</title>
</head>
<body>
  <header class="header">
    <div class="section__container header__container_domaine">
      <h2>Conception d'un convoyeur</h2>
    </div>
  </header>

  <div class="layout-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-toggle" id="sidebarToggle">
        <i class="fas fa-bars"></i>
      </div>

      <nav class="main-nav">
        <a href="index.html" class="nav-link"><i class="fas fa-home"></i> Accueil</a>
        <a href="it.html" class="nav-link"><i class="fas fa-desktop"></i> IT</a>
        <a href="electronique.html" class="nav-link"><i class="fas fa-microchip"></i> Électronique</a>
        <a href="mecanique.html" class="nav-link"><i class="fas fa-cogs"></i> Mécanique</a>
        <a href="convoyeur1.html" class="nav-link"></i><i class="fas fa-robot"></i> Convoyeur 1</a>
        
        <div class="nav-section">
         <button class="tab-button active" data-target="conveyor2-content"><i class="fas fa-robot"></i> Convoyeur 2</button>
          <div class="sub-links">
            <a class="subtab-button active" data-target="intro2" href="#introduction2">Généralité</a>

            <nav class="project-subnav active" id="subnav-intro2">
              <a href="#1-intro2">1. Contexte</a>
              <a href="#2-intro2">2. Objectifs</a>
              <a href="#3-intro2">3. Présentation du système</a>
              <a href="#4-intro2">4. Technologies utilisées</a>
            </nav>

            <a class="subtab-button" data-target="cahier2" href="#cahier_de_charge2">Cahier de charge</a>
            <nav class="project-subnav" id="subnav-cahier2">
              <a href="#1-cahier2">1. Besoins fonctionnels</a>
              <a href="#2-cahier2">2. Contraintes</a>
            </nav>

            <a class="subtab-button" data-target="meca2" href="#mecanique2">Partie mécanique</a>
            <nav class="project-subnav" id="subnav-meca2">
              <a href="#1-meca2">1. Étude de conception mécanique</a>
              <a href="#2-meca2">2. Choix des composants mécaniques</a>
              <a href="#3-meca2">3. Modélisation CAO (SolidWorks)</a>
              <a href="#4-meca2">4. Réalisation</a>
            </nav>

            <a class="subtab-button" data-target="electro2" href="#electronique2">Partie électronique</a>
            <nav class="project-subnav" id="subnav-electro2">
              <a href="#1-electro2">1. Cahier de charge</a>
              <a href="#2-electro2">2. Schéma synoptique</a>
              <a href="#3-electro2">3. Description fonctionnelle </a>
              <a href="#4-electro2">4. Tests et validation</a>
              <a href="#5-electro2">5. Réalisation du PCB</a>
              <a href="#6-electro2">6. Prototype final</a>
            </nav>

            <a class="subtab-button" data-target="info2" href="#informatique2">Partie informatique</a>
            <nav class="project-subnav" id="subnav-info2">
              <a href="#1-info2">1. Détection intelligente et automatisation</a>
              <a href="#2-info2">2. Interface Web</a>
              <a href="#3-info2">3. Architecture technique et Technologies utilisées</a>
              <a href="#4-info2">4. Communication série et Traitement des Données</a>
              <a href="#5-info2">5. Instructions d'utilisation</a>
            </nav>

            <a class="subtab-button" data-target="test2" href="#validation2">Test et validation</a>
            <nav class="project-subnav" id="subnav-test2">
              <a href="#1-test2">1. Assemblage du convoyeur</a>
              <a href="#2-test2">2. Protocole de test</a>
              <a href="#3-test2">3. Résultats et démonstration</a>
            </nav>

            <a class="subtab-button" data-target="concl2" href="#conclusion2">Conclusion et Annexes</a>
            <nav class="project-subnav" id="subnav-concl2">
              <a href="#1-concl2">1. Conclusion et perspectives</a>
              <a href="#2-concl2">2. Annexes</a>
            </nav>

          </div>
        </div>

      </nav>
    </div>

    <!-- Contenu principal -->
    <main class="main-content">
      <section id="convoyeur-content" class="tab-content active">

        <div id="introduction2" class="subtab-content active">
          <h2 id="intro2" class="projet-titre">Introduction générale</h2>
          <h3 id="1-intro2">1. Contexte</h3>
            <p>
               Dans le cadre du développement durable et de l’optimisation des processus industriels, 
               la ville industrielle de TEKBOT CITY souhaite accueillir une nouvelle entreprise spécialisée dans le recyclage des déchets. 
               Afin de <strong>moderniser</strong> ses infrastructures et de renforcer l’efficacité du <strong>tri</strong>, 
               il est envisagé d’installer un <strong>système intelligent de convoyeur</strong> capable d’identifier, 
               trier et comptabiliser automatiquement différents types de déchets.
            </p>

            <p>
              Ce projet s'inscrit dans le cadre de la TRC 2025, un challenge technologique pluridisciplinaire visant à combiner la <strong>mécanique</strong>, 
              l’<strong>électronique</strong> et l’<strong>informatique embarquée</strong> pour résoudre des problématiques industrielles concrètes.
            </p>
          <h3 id="2-intro2">2. Objectifs</h3>
            <p>
              L’objectif principal de ce projet est de concevoir, réaliser et tester 
              un <strong>système de convoyeur intelligent</strong> capable de :
              <ul>
                <li>Détecter la présence d’un objet(un déchet) sur un tapis roulant,</li>
                <li>Identifier sa couleur et son type(Rouge, Vert, Jaune, Bleu) à l’aide d’un capteur adapté,</li>
                <li>Compter chaque type de déchet détecté,</li>
                <li>Et afficher en temps réel ces données sur une interface web destinée aux administrateurs</li>
              </ul>
            </p>
          <h3 id="3-intro2">3. Présentation du système</h3>
            <p>
              Le système est composé de trois grandes parties interconnectées :
            </p>
            <ul>
              <li>
                <strong>La bande transporteuse</strong>(convoyeur) reste immobile en l’absence de déchet 
                et s’active automatiquement dès qu’un objet est détecté par un capteur de présence. 
                Elle transporte le déchet jusqu’à une zone de dépôt.
              </li>
              <li>
                <strong>Le module de tri</strong> utilise un capteur de couleur pour identifier l’objet. 
                Un algorithme embarqué analyse cette couleur et classe le déchet dans une catégorie définie. 
                En fin de course, une indication visuelle informe l’équipe de collecte sur le bac approprié.
              </li>
              <li>
                <strong>L’interface web</strong> reçoit les données via une communication série (Web Serial API) 
                et affiche dynamiquement le nombre de déchets triés par couleur. Elle offre une visualisation claire, et permet un suivi en direct.
              </li>
            </ul>
          <h3 id="4-intro2">4. Technologies utilisées</h3>
            <p>
              Le projet exploite un ensemble cohérent de technologies issues des trois domaines du projet :
            </p>
            <table border="2" cellspacing="1" cellpadding="6">
              <thead>
                <tr>
                  <th>Domaine</th>
                  <th>Technologies / Outils utilisés</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Électronique</strong></td>
                  <td>Arduino Nano, capteur de couleur(ColorPal), capteur de présence(Ultrason), moteur DC, LED RGB, driver moteur, alimentation Li‑Ion</td>
                </tr>
                <tr>
                  <td><strong>Informatique</strong></td>
                  <td>HTML, CSS, JavaScript (Web Serial API), Python, Chart.js pour les graphiques, communication série USB</td>
                </tr>
                <tr>
                  <td><strong>Mécanique</strong></td>
                  <td>Conception CAO sur SolidWorks, tapis roulant, structure en bois et plastique</td>
                </tr>
              </tbody>
            </table>
        </div>

        <div id="cahier2" class="subtab-content">
          <h2 id="cahier_de_charge2" class="projet-titre">Cahier de charge</h2>
          <h3 id="1-cahier2">1. Besoins fonctionnels</h3>
            <p>
              Le système de convoyeur doit répondre aux besoins suivants
            </p>
            <ul>
              <li>
                <strong>Tri intelligent de 4 types de déchets</strong>, représentés par des objets de couleurs différentes:
                <ul>
                  <li>Rouge → Type 1</li>
                  <li>Vert → Type 2</li>
                  <li>Jaune → Type 3</li>
                  <li>Bleu → Type 4</li>
                </ul>
              </li>
              <li><strong>Détection automatique de la présence</strong> d’un objet sur la bande transporteuse à l’aide d’un capteur de présence</li>
              <li><strong>Identification précise</strong> de la couleur du déchet via un capteur de couleur.</li>
              <li><strong>Activation automatique</strong> du convoyeur uniquement lorsqu’un objet est détecté.</li>
              <li><strong>Indication claire de la catégorie de tri</strong>, pour permettre une collecte manuelle efficace dans les bacs correspondants.</li>
              <li><strong>Visualisation en temps réel</strong>l sur une interface web intuitive, permettant à l’administrateur de :</li>
              <ul>
                <li>Suivre le nombre de déchets triés par type.</li>
                <li>Suivre la performance du système</li>
                <li>Intervenir en cas de problème</li>
              </ul>
            </ul>


          <h3 id="2-cahier2">2. Contraintes</h3>
            <p>
              Le système doit respecter un ensemble de contraintes techniques fixées :
            </p>
            <ul>
              <li>
                <strong>Alimentation autonome</strong> à partir d’un bloc de batteries lithium, garantissant une mobilité et une sécurité énergétique.
              </li>
              <li>
                <strong>Détection obligatoire par un système de capteurs imposés :</strong>
                <ul>
                  <li>Capteur de présence</li>
                  <li>Capteur de couleur</li>
                </ul>
              </li>
              <li>
                <strong>Microcontrôleur imposé :</strong> Arduino Nano ou ATmega
              </li>
              <li>
                <strong>Contraintes mécaniques précises :</strong>
                <ul>
                  <li>Longueur du convoyeur : 650 mm.</li>
                  <li>Hauteur du tapis par rapport au sol : 100 mm.</li>
                </ul>
              </li>
              <li>
                <strong>Poids et dimensions des objets à trier :</strong>
                <ul>
                  <li>Forme : cube.</li>
                  <li>Taille : 30 mm de côté.</li>
                </ul>
              </li>
            </ul>
        </div>

        <div id="mecanique2" class="subtab-content">
          <h2 id="meca2" class="projet-titre">Partie mécanique</h2>
          <h3 id="1-meca2">1. Étude de conception mécanique(Analyse fonctionnelle)</h3>
              <p>
                L’analyse fonctionnelle est une démarche essentielle dans la conception d’un système technique. 
                Elle vise à identifier, comprendre et formaliser les besoins réels des utilisateurs ainsi que les fonctions que le système doit remplir pour y répondre. 
                Dans le cadre de ce projet, qui consiste à développer un système de convoyeur intelligent pour le tri de déchets(considérés ici comme des objets colorés), l’analyse fonctionnelle permettra de structurer la réflexion en distinguant les fonctions principales, les contraintes techniques, et les interactions entre les différents composants. 
              </p>
            
            <h4>a. Analyse de besoin:</h4>
              <p>
                La bête à cornes est un diagramme représenté sous forme de graphique. 
                Il permet de savoir si un produit ou un service répond aux besoins des utilisateurs. 
                Elle est appelée bête à corne, car elle ressemble à une tête de taureau avec la ligne reliant les deux boules en haut du diagramme.
                Pour débuter, nous allons commencer par faire une analyse de besoin en utilisant ce diagramme de bête à corne qui va nous permettre de répondre aux trois questions suivantes:
                <ul>
                  <li>Qui utilise le système ?</li>
                  <li>Sur quoi agit-il ?</li>
                  <li>Dans quel but ?</li>
                </ul>
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Mecanique/analyse1.png" alt="analyse" class="image-mean"/>
              </div>

              <h4>b. Énoncé du besoin</h4>
                <p>
                  Notre système de convoyeur rend service à une entreprise de recyclage dans la zone industrielle de TECHBOT CITY 
                  en permettant de trier automatiquement des déchets en fonction de leurs couleurs afin de faciliter la collecte.  
                </p>

              <h4>c. Analyse fonctionnelle du besoin (AFB)</h4>
                <p>
                  Une analyse fonctionnelle de besoin se concentre sur l'identification de deux types principaux de fonctions: les fonctions principales et les fonctions contraintes.
                  Les fonctions principales décrivent ce que le produit ou système doit faire pour satisfaire le besoin de l'utilisateur, tandis que les fonctions contraintes 
                  définissent les limites ou les conditions dans lesquelles ces fonctions principales doivent être réalisées.
                </p>
                <p>
                  <strong>Fonctions principales:</strong>
                  <ul>
                    <li>Elles sont la raison d'être du produit ou du système.</li>
                    <li>Elles répondent directement au besoin de l'utilisateur. </li>
                    <li>Elles peuvent être décomposées en fonctions élémentaires pour une analyse plus détaillée.</li>
                  </ul>
                </p>

                <p>
                  <strong>Fonctions contraintes</strong>
                  <ul>
                    <li>Elles limitent les choix du concepteur et du produit.</li>
                    <li>Elles peuvent être liées à la sécurité, l'environnement, l'ergonomie, etc.</li>
                    <li>Exemple: "Être compatible avec les normes de sécurité" pour une voiture. </li>
                  </ul>
                </p>

                <p>
                  En plus de ces fonctions principales et les fonctions de contraintes, 
                  nous allons ajouter et détailler des fonctions de services pour mieux satisfaire les besoins de l’entreprise de faire le système de tri avec le convoyeur.
                </p>
                <p>
                  En résumé, l'analyse fonctionnelle de besoin vise à identifier 
                  et à caractériser ces deux types de fonctions afin de bien comprendre les exigences du produit et de garantir sa pertinence par rapport au besoin initial. 
                </p>
                
                <p>
                  Pour bien étudier notre système et pour définir les fonctions principales et les fonctions de contraintes, nous allons utiliser le diagramme de pieuvre.
                </p>
                <div class="image-container">
                  <p>Diagramme de pieuvre:</p>
                  <img src="images/Test4_2/Mecanique/analyse2.png" alt="analyse" class="image-mean"/>
                </div>

                <table border="2" cellspacing="1" cellpadding="6">
                  <tbody>
                  <tr>
                    <td>FP1</td>
                    <td>transférer les déchets</td>
                  </tr>
                  <tr>
                    <td>FP2</td>
                    <td>trier les déchets</td>
                  </tr>
                  <tr>
                    <td>FP3</td>
                    <td>interface web pour affichage</td>
                  </tr>
                  <tr>
                    <td>FC1</td>
                    <td>utiliser l'arduino nano</td>
                  </tr>
                  <tr>
                    <td>FC2</td>
                    <td>alimentation batterie lithium</td>
                  </tr>
                  <tr>
                    <td>FC3</td>
                    <td>le convoyeur ne doit fonctionner que si un déchet est présent</td>
                  </tr>
                  <tr>
                    <td>FC4</td>
                    <td>le capteur de présence(Ultrason)</td>
                  </tr>
                  <tr>
                    <td>FC5</td>
                    <td>
                      dimension:
                      <ul>
                        <li style="font-size: 1rem;">longueur du convoyeur: 650 mm</li>
                        <li style="font-size: 1rem;">hauteur du tapis: 100 mm</li>
                        <li style="font-size: 1rem;">largeur du tapis: 50 mm</li>
                      </ul>
                    </td>
                  </tr>
                  <tr>
                    <td>FC6</td>
                    <td>les déchets sous formes de cubes de 30 mm</td>
                  </tr>
                  <tr>
                    <td>FS1</td>
                    <td>détecter la présence d'un déchet</td>
                  </tr>
                  <tr>
                    <td>FS2</td>
                    <td>identifier la couleur du déchet</td>
                  </tr>
                  <tr>
                    <td>FS3</td>
                    <td>déplacer le tapis du convoyeur</td>
                  </tr>
                  <tr>
                    <td>FS4</td>
                    <td>afficher les statistiques de tri en temps réel sur une interface web</td>
                  </tr>
                  <tr>
                    <td>FS5</td>
                    <td>indiquer à l'utilisateur dans quelle benne placer le déchet</td>
                  </tr>
                </tbody>
              </table>

            <h4>d. Diagramme FAST</h4>
              <p>
                Le diagramme FAST (Function Analysis System Technique) est la représentation visuelle d'un produit ou d’un système et de toutes ses fonctions.
                Ce diagramme est un outil utilisé par les entreprises pour obtenir une vision globale d'un produit existant ou en cours de création. Il représente schématiquement toutes les fonctions de l'article et la manière dont il les met en œuvre.
              </p>
              <p><strong>À quoi sert le diagramme FAST ?</strong></p>
              <p>
                Il répond à trois grandes questions pour chaque fonction :
                <ul>
                  <li>Pourquoi ?</li>
                  <li>Comment ?</li>
                  <li>Quand ?</li>
                </ul>
              </p>
              <p>
                Il représente <strong>graphiquement</strong> les relations entre les fonctions principales (FP) et les fonctions de service (FS)
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Mecanique/analyse3.png" alt="analyse" class="image-mean"/>
              </div>
            <h4>e. Conclusion générale de l’analyse fonctionnelle</h4>
              <p>
                L’analyse fonctionnelle a permis d’identifier clairement les fonctions principales du système de convoyeur : trier automatiquement les déchets selon leur couleur.
                Pour répondre efficacement à ce besoin, plusieurs fonctions de service ont été définies, telles que la détection de présence, l’identification de couleur, le déplacement du tapis et l’affichage des statistiques en temps réel.
              </p>
              <p>
                Les fonctions contraintes imposées par le cahier des charges (composants à utiliser, dimensions, alimentation etc.) ont été intégrées dans la conception dès les premières étapes
              </p>
              <p>
                Cette analyse permet ainsi de poser une base solide pour la phase de conception et garantit que le système répondra aux attentes techniques, fonctionnelles et ergonomiques de l’entreprise utilisatrice.
              </p>
            
            

          <h3 id="2-meca2">2. Choix des composants mécaniques</h3>
            <p>
              Ayant déjà du bois comme matière première, nous avons décidé de l’utiliser, 
              ainsi que d’autres composants déjà en notre possession tels que le tapis et les roulements.
            </p>
            <p>
              Voici donc le tableau récapitulatif des composants utilisés et de leur rôle :
            </p>
            <table border="2" cellspacing="1" cellpadding="6">
              <thead>
                <tr>
                  <th>Composants</th>
                  <th>Matériaux</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Parois latérales</strong></td>
                  <td>Bois</td>
                </tr>
                <tr>
                  <td><strong>Tapis</strong></td>
                  <td>Textile</td>
                </tr>
                <tr>
                  <td><strong>Roulements</strong></td>
                  <td>Acier</td>
                </tr>
                <tr>
                  <td><strong>Tambours</strong></td>
                  <td>Plastique</td>
                </tr>
                <tr>
                  <td><strong>Supports des tambours</strong></td>
                  <td>Plastique</td>
                </tr>
                <tr>
                  <td><strong>Supports des composants électroniques</strong></td>
                  <td>Plastique</td>
                </tr>
              </tbody>
            </table>
          <h3 id="3-meca2">3. Modélisation CAO (SolidWorks)</h3>
            <p>
              Nous avons conçu les différentes pièces puis avons assemblé sur <strong>SolidWorks</strong> 
              en respectant les dimensions du cahier de charge.
            </p>
            <h4>a. Parois latérales</h4>
              <p>
                Il s'agit de la structure principale du convoyeur.
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Mecanique/parois1.png" alt="parois" class="image-mean"/>
                <img src="images/Test4_2/Mecanique/parois2.png" alt="parois" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Bords.rar" download class="download-link">télécharger les parois latérales</a>
                </p> 
              </div>

            <h4>b. Tapis</h4>
              <p>
                Il s'agit de la structure principale du convoyeur.
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Mecanique/tapis1.png" alt="tapis" class="image-mean"/>
                <img src="images/Test4_2/Mecanique/tapis2.png" alt="tapis" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Tapis.SLDPRT" download class="download-link">télécharger le tapis</a>
                </p> 
              </div>

            <h4>c. Roulements</h4>
              <p>
                Il s'agit de la structure principale du convoyeur.
              </p>

              <div class="image-container">
                <p>Interieur du roulement:</p>
                <img src="images/Test4_2/Mecanique/roulements1.png" alt="roulements" class="image-small"/>
                <img src="images/Test4_2/Mecanique/roulements2.png" alt="roulements" class="image-small"/>
              </div>

              <div class="image-container">
                <p>Exterieur du roulement:</p>
                <img src="images/Test4_2/Mecanique/roulements3.png" alt="roulements" class="image-small"/>
                <img src="images/Test4_2/Mecanique/roulements4.png" alt="roulements" class="image-small"/>
                <img src="images/Test4_2/Mecanique/roulements5.png" alt="roulements" class="image-small"/> 
              </div>

              <div class="image-container">
                <p>Le roulement assemblé:</p>
                <img src="images/Test4_2/Mecanique/roulements6.png" alt="roulements" class="image-mean"/> 
              </div>

              <p class="txt_center">
                <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Roulement.rar" download class="download-link">télécharger les fichiers du roulement</a>
              </p>

            <h4>d. Tambours</h4>
              <p>
                Les deux tambours entrainent le tapis en rotation.
                L'un des tambours est connecté au moteur.
              </p>
              
              <div class="image-container">
                <p>Tambour connecté au moteur</p>
                <img src="images/Test4_2/Mecanique/tambours_motor1.png" alt="tambours_motor" class="image-small"/>
                <img src="images/Test4_2/Mecanique/tambours_motor2.png" alt="tambours_motor" class="image-small"/>
                <img src="images/Test4_2/Mecanique/tambours_motor3.png" alt="tambours_motor" class="image-small"/>
                <img src="images/Test4_2/Mecanique/tambours_motor4.png" alt="tambours_motor" class="image-small"/>             
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Cylindre%20convoyeur%20moteur.SLDPRT" download class="download-link">télécharger le tambour connecté au moteur</a>
                </p> 
              </div>

              <div class="image-container">
                <p>Tambour libre</p>
                <img src="images/Test4_2/Mecanique/tambours_libre1.png" alt="tambours_libre" class="image-small"/>
                <img src="images/Test4_2/Mecanique/tambours_libre2.png" alt="tambours_libre" class="image-small"/>
                <img src="images/Test4_2/Mecanique/tambours_libre3.png" alt="tambours_libre" class="image-small"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Cylindre%20conv.SLDPRT" download class="download-link">télécharger le tambour libre</a>
                </p> 
              </div>
              
            <h4>e. Supports des tambours</h4>
              <p>
                Ils permettent de relier les parois, les roulement et les tambours.
              </p>
              <div class="image-container">
                <p>Support du tambour côté moteur</p>
                <img src="images/Test4_2/Mecanique/support_tambours_motor1.png" alt="support_tambours_motor" class="image-small"/>
                <img src="images/Test4_2/Mecanique/support_tambours_motor2.png" alt="support_tambours_motor" class="image-small"/>
                <img src="images/Test4_2/Mecanique/support_tambours_motor3.png" alt="support_tambours_motor" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Roller__Holder_inside.SLDPRT" download class="download-link">télécharger le support du tambour côté moteur</a>
                </p> 
              </div>

              <div class="image-container">
                <p>Support des tambours libres</p>
                <img src="images/Test4_2/Mecanique/support_tambours_libre1.png" alt="support_tambours_libre" class="image-small"/>
                <img src="images/Test4_2/Mecanique/support_tambours_libre2.png" alt="support_tambours_libre" class="image-small"/>
                <img src="images/Test4_2/Mecanique/support_tambours_libre3.png" alt="support_tambours_libre" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Roller__Holder.SLDPRT" download class="download-link">télécharger le support du tambour libre</a>
                </p> 
              </div>
            

            <h4>f. Supports des composants électroniques et autres</h4>
              <p>
                Ils permettent de supporter et de fixer les composants électroniques.
              </p>
              <div class="image-container">
                <p>Support Ultrason et moteur</p>
                <img src="images/Test4_2/Mecanique/support_composant1.png" alt="support_composant" class="image-small"/>
                <img src="images/Test4_2/Mecanique/support_composant2.png" alt="support_composant" class="image-small"/>
                <img src="images/Test4_2/Mecanique/support_composant3.png" alt="support_composant" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Support_Ultrason.SLDPRT" download class="download-link">télécharger le support Ultrason et moteur</a>
                </p> 
              </div>
              
              <div class="image-container">
                <p>Support du capteur de couleur, de la led RGB et des boutons poussoirs</p>
                 <img src="images/Test4_2/Mecanique/support_composant4.png" alt="support_composant" class="image-small"/>
                 <img src="images/Test4_2/Mecanique/support_composant5.png" alt="support_composant" class="image-small"/>
                 <img src="images/Test4_2/Mecanique/support_composant6.png" alt="support_composant" class="image-small"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Support_ColorSencor.SLDPRT" download class="download-link">télécharger le support du capteur de couleur et des boutons poussoirs</a>
                </p> 
              </div>

              <div class="image-container">
                <p>Support du capteur infrarouge</p>
                 <img src="images/Test4_2/Mecanique/support_infrarouge.png" alt="support_infrarouge" class="image-small"/>
                 <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/support_infrarouge.SLDPRT" download class="download-link">télécharger le support du capteur infrarouge</a>
                </p> 
              </div>

              <div class="image-container">
                <p>Un support au milieu du convoyeur pour le circuit</p>
                 <img src="images/Test4_2/Mecanique/support_pcb.png" alt="support_pcb" class="image-small"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/supportConvoyeur_milieu.SLDPRT" download class="download-link">télécharger le support du convoyeur et du circuit</a>
                </p> 
              </div>

              <div class="image-container">
                <p>Deux supports aux extrémités pour fixer le convoyeur au sol</p>
                <img src="images/Test4_2/Mecanique/support_extremite.png" alt="support_extremite" class="image-small"/>
                <p>
                  <a href="https://githhttpsub.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/supportConvoyeur.SLDPRT" download class="download-link">télécharger le support du convoyeur</a>
                </p> 
              </div>

            <h4>g. Moteur DC</h4>
              <p>
                Il s'agit de la structure principale du convoyeur.
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Mecanique/moteur1.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur2.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur3.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur4.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur5.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur6.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur7.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur8.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur9.png" alt="moteur" class="image-small"/>
                <img src="images/Test4_2/Mecanique/moteur10.png" alt="moteur" class="image-small"/>
              </div>

              <div class="image-container">
                <img src="images/Test4_2/Mecanique/moteur11.png" alt="moteur" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Motor%20DC.rar" download class="download-link">télécharger le moteur DC</a>
                </p> 
              </div>

            <h4>h. Le convoyeur assemblé</h4>
              <p>
                A partir de ces pièces, nous avons assemblé le convoyeur.
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Mecanique/assemblage1.png" alt="assemblage" class="image-small"/>
                <img src="images/Test4_2/Mecanique/assemblage2.png" alt="assemblage" class="image-small"/>
                <img src="images/Test4_2/Mecanique/assemblage3.png" alt="assemblage" class="image-small"/>
                <img src="images/Test4_2/Mecanique/assemblage5.png" alt="assemblage" class="image-small"/>
                <img src="images/Test4_2/Mecanique/assemblage4.png" alt="assemblage" class="image-small"/>
                <img src="images/Test4_2/Mecanique/assemblage6.png" alt="assemblage" class="image-mean"/>
                <p>
                  <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/Assemblage.SLDASM" download class="download-link">télécharger le convoyeur assemblé</a>
                </p> 
              </div>

            <p class="txt_center">
              Télécharger l'ensemble(pièces et assemblages) <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Mecanique/B2MS_convoyeur_CAO.rar" download class="download-link">ici</a>
            </p> 

          <h4 id="4-meca2">4. Réalisation</h4>
           <p>
            Les pièces en plastique nécessaires au montage ont été modélisées puis imprimées à l’aide d’une imprimante 3D.
           </p>
           <div class="image-container">
              <img src="images/Test4_2/Mecanique/impression3d1.jpg" alt="impression" class="image-small"/>
              <img src="images/Test4_2/Mecanique/impression3d2.jpg" alt="impression" class="image-small"/>
            </div>

            <video controls width=30%>
              <source src="videos/Test4_2/Mecanique/impression3d1.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>
            <video controls width=30%>
              <source src="videos/Test4_2/Mecanique/impression3d2.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>

           <p>
            Le bois a été découpé en respectant les dimensions définies sur SolidWorks, garantissant une structure précise.
            Pour la fabrication du tapis roulant, un textile utilisé habituellement pour les sacs a été choisi, assurant une bonne résistance.
           </p>
           <div class="image-container">
              <img src="images/Test4_2/Mecanique/realisation_piece1.jpg" alt="realisation_piece" class="image-small"/>
              <img src="images/Test4_2/Mecanique/realisation_piece2.jpg" alt="realisation_piece" class="image-small"/>
              <img src="images/Test4_2/Mecanique/montage1.png" alt="realisation_conv" class="image-mean"/>
              <img src="images/Test4_2/Mecanique/montage2.jpg" alt="realisation_conv" class="image-mean"/>
              <img src="images/Test4_2/Mecanique/realisation_conv2.jpg" alt="realisation_conv" class="image-small"/>
            </div>
   
            <p>
              Cette méthode a permis d’obtenir des composants parfaitement adaptés au système.
            L'ensemble a été assemblé avec soin pour assurer la stabilité et la fonctionnalité du convoyeur.
            </p>

            <div class="image-container">
              <img src="images/Test4_2/Mecanique/conv1.png" alt="realisation_conv" class="image-mean"/>
              <img src="images/Test4_2/Mecanique/conv2.jpg" alt="realisation_conv" class="image-mean"/>
            </div>

        </div>

        <div id="electronique2" class="subtab-content">
          <h2 id="electro2" class="projet-titre">Partie électronique</h2>
          <h3 id="1-electro2">1. Cahier de charge</h3>
            <p>
            Dans le cadre d’un projet final en systèmes embarqués, le but est de concevoir un <strong>système automatisé de tri de déchets</strong> 
            inspiré des procédés industriels de recyclage.
            </p> 
            
            <h4>a. Objectifs fonctionnels</h4>
              <ul>
                <li>Détecter la présence d’un objet/déchet sur la bande.</li>
                <li>Mettre en mouvement la bande uniquement si un déchet est détecté.</li>
                <li>Détecter la couleur de l’objet (cube) en mouvement.</li>
                <li>Afficher la couleur via une LED RGB.</li>
                <li>Transmettre la couleur détectée à une interface web via Wi-Fi.</li>
              </ul>

            <h4>b. Contraintes techniques</h4>
              <ul>
                <li>Alimentation sur 3 piles Li-ion 3,7V (≈11,1V).</li>
                <li>Conversion de tension via module buck MP2307 vers 5V.</li>
                <li>Circuit centré sur une Arduino Nano.</li>
                <li>Capteurs alimentés en 5V.</li>
                <li>Utilisation minimale de composants externes (driver moteur simple par MOSFET). </li>
              </ul>

            <h4>c. Composants utilisés</h4>
              <table border="2" cellspacing="1" cellpadding="6">
                <tbody>
                  <tr>
                    <td><strong>Arduino Nano</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Capteur à ultrasons HC-SR04</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Capteur de couleur TCS230</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Capteur infrarouge</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>LED RGB</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Moteur DC 6-12V</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Module WiFi (ESP-01)</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>MOSFET canal N (IRFZ44N)</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Régulateur buck MP2307</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Boutons poussoirs</strong></td>
                    <td>2</td>
                  </tr>
                  <tr>
                    <td><strong>Interrupteur</strong></td>
                    <td>1</td>
                  </tr>                 
                  <tr>
                    <td><strong>Diode de roue libre (1N4007)</strong></td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td><strong>Résistances, câblage</strong></td>
                    <td>-</td>
                  </tr>
                </tbody>
            </table>

          <h3 id="2-electro2">2. Schéma synoptique</h3>
            <div class="image-container">
              <img src="images/Test4_2/Electronique/schema_synoptique.png" alt="schema_synoptique" class="image-mean"/>
            </div>
    
          <h3 id="3-electro2">3. Description fonctionnelle des blocs</h3>
             <h4>a. Le microcontrôleur(Arduino Nano)</h4>
              <p>
                L'Arduino Nano est une carte microcontrôleur compacte et polyvalente basée sur l'ATmega328P. 
                Ses broches et ses caractéristiques techniques lui confèrent de nombreuses fonctionnalités.
              </p>

              <p>
                Il constitue le cœur de notre système. 
                C’est lui qui reçoit l’ensemble des données issues des capteurs et qui pilote les différents actionneurs : 
                l’éclairage <strong>RGB</strong>, le <strong>moteur</strong> (pour le démarrage et l’arrêt du tapis), ainsi que les <strong>boutons</strong> de mise en marche et d’arrêt du système.
                Sans ce composant central, aucun fonctionnement n’est possible.
              </p>
              <p>
                Son fonctionnement repose sur un programme écrit en langage C, spécifiquement conçu pour coordonner tous les éléments du système.
              </p>
              <p>
                Dans la suite du document, nous détaillerons le code ainsi que le schéma de câblage, en précisant à quelles broches de l’Arduino Nano chaque capteur ou composant est connecté.
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Electronique/arduino_nano.png" alt="nano" class="image-mean"/>
              </div>

              <ul>
                <strong>Quelques caractéristiques:</strong>
              </ul>
              <table border="2" cellspacing="1" cellpadding="6">
                <thead>
                  <tr>
                    <th></th>
                    <th>Rôles</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><strong>Vin, 5V, 3.3V</strong></td>
                    <td>Alimentation</td>
                  </tr>
                  <tr>
                    <td><strong>Reset</strong></td>
                    <td>Réinitialisation du microcontrôleur.</td>
                  </tr>
                  <tr>
                    <td><strong>Broches analogiques(A0 – A7)</strong></td>
                    <td>Entrée analogique</td>
                  </tr>
                  <tr>
                    <td><strong>Broches numériques (D0 – D13)</strong></td>
                    <td>Entrée/Sortie numérique uniquement</td>
                  </tr>
                  <tr>
                    <td><strong>Série (Rx, Tx)</strong></td>
                    <td>Transmission et la réception de données série TTL</td>
                  </tr>
                  <tr>
                    <td><strong>PWM (3, 5, 6, 9, 11)</strong></td>
                    <td>Sortie PWM 8 bits</td>
                  </tr>
                  <tr>
                    <td><strong>SPI (10, 11, 12, 13)</strong></td>
                    <td>Communication SPI</td>
                  </tr>
                </tbody>
              </table>

            <h4>b. Bloc d'alimentation</h4>
              <p>
                Le système est alimenté par <strong>trois batteries Li-Ion 3.7V</strong> montées en série (tension totale ≈11.1V). 
                Cette tension alimente directement le moteur via le circuit MOSFET. 
                Pour alimenter les composants électroniques en 5V, un <strong>module buck MP2307</strong> est utilisé. 
                Ce module convertit efficacement la tension 11.1V vers 5V avec un bon rendement.
              </p>
              <div class="image-container">
                <img src="images/Test4_2/Electronique/alimentation.png" alt="bloc_alimentation" class="image-mean"/>
                <img src="images/Test4_2/Electronique/buck.jpg" alt="bloc_alimentation" class="image-small"/>
              </div>
              <p>
                <ul>
                  <li><strong>Avantages du MP2307</strong>: faible échauffement, grande stabilité, courant jusqu’à 2A. </li>
                </ul>
              </p>

              <h4>c. Les capteurs</h4>
              <h5>&#10022; Capteur à ultrasons (HC-SR04)</h5>
                <p>
                  Le capteur à ultrasons détermine la distance d’un objet par rapport à sa position.
                  Il génère un signal à bande étroite à une fréquence de 40 kHz et capte le signal réfléchi(écho). 
                  Sur la base du temps de propagation du son vers et depuis l’objet, la distance (en centimètres) peut être déterminée assez précisément.
                  Ce capteur permet donc de détecter la présence d'une pièce tout le long du convoyeur.                 
                </p>
                <div class="image-container">
                  <img src="images/Test4_2/Electronique/ultrasonic.jpg" alt="Ultrason" class="image-mean"/>
                </div>

                <p>
                  <ul>
                    <li>
                      <strong>TRIG</strong>(OUTPUT) envoie une impulsion électrique de 10 microsecondes pour déclencher la mesure. 
                      Cette impulsion commande au capteur d’émettre une onde ultrasonore.
                    </li>
                    <li>
                      <strong>Echo</strong>(INPUT) reçoit l’onde ultrasonore réfléchie par un objet et passe à l’état HAUT pendant une durée proportionnelle à la distance mesurée. 
                      Cette durée est utilisée pour calculer la distance entre le capteur et l’objet.
                    </li>
                  </ul>
                </p>

                <div class="image-container">
                  <img src="images/Test4_2/Electronique/circuit_ultrason.png" alt="Ultrason" class="image-mean"/>
                </div>
                
                <div class="code-container">
                  <p>code_ultrasonic.ino </p>
                  <div class="btn-bar">
                    <button onclick="copierCode('code_ultrasonic-ino', this)">📋</button>
                    <button onclick="telechargerCode('code_ultrasonic-ino', 'code_ultrasonic.ino', 'text/ino', this)">🡇</button>
                  </div>
                  <pre><code id="code_ultrasonic-ino">
    #define trigPin 5 // Définir la broche 2 pour le Trig
    #define echoPin 6 // Définir la broche 3 pour l'Echo

    long distance = 0;  //stocke la distance calculée

    void setup() {
      pinMode(trigPin, OUTPUT); // Configurer trigPin en sortie
      pinMode(echoPin, INPUT); // Configurer echoPin en entrée
      Serial.begin(9600); // Initialiser la communication série à 9600 bauds
    }

    void loop() {
      distance = getDistance(); 

      // Afficher la distance sur le moniteur série
      Serial.print("Distance: ");
      Serial.print(distance);
      Serial.println(" cm");

      delay(1000); // Attendre 1 seconde avant de refaire une lecture
    }

    long getDistance() {
      // Envoyer une impulsion de 10 µs pour déclencher le capteur
      digitalWrite(trigPin, LOW);
      delayMicroseconds(2);
      digitalWrite(trigPin, HIGH);
      delayMicroseconds(10);
      digitalWrite(trigPin, LOW);

      // Mesurer la durée de l'écho
      long duration = pulseIn(ECHO_PIN, HIGH);
      
      // Calculer la distance en cm
      long distance = (duration / 2) * 0.0344;  // Vitesse du son = 0.0344 cm/µs
      
      return distance;
    }
                </code></pre>
              </div>

              <h5>&#10022; Capteur infrarouge</h5>
                <p>
                  Placé en bout de convoyeur, à une distance adéquate, il <strong>émet un faisceau infrarouge</strong> à courte portée à l’aide d’une LED de 940 nm. 
                  Lorsqu’un objet s’approche, la lumière infrarouge est partiellement <strong>réfléchie vers un récepteur photoélectrique intégré</strong>. 
                  Cette variation de lumière permet au module de générer un signal numérique indiquant la présence ou l'absence d’un obstacle.
                </p>
                <p>
                  Compatible avec une alimentation de 3,3 V à 5 V et consommant jusqu’à 100 mA, le capteur s’adapte à la plupart des microcontrôleurs. 
                  Il fonctionne à une fréquence de 38 kHz, limitant les interférences dues à la lumière ambiante, et peut opérer dans des températures allant de -25 °C à +55 °C.
                  Sa robustesse et sa précision en font un composant essentiel pour assurer un arrêt précis du convoyeur en fin de cycle.
                </p>
                
                <p>
                  <strong>NB:</strong> le potentiomètre intégré permet d'ajuster la plage de détection du module.
                </p>
                <div class="image-container">
                  <img src="images/Test4_2/Electronique/infrared.png" alt="infrared" class="image-mean"/>
                </div>

                <ul>
                  <strong>Sortie logique: </strong>
                  <li><strong>HIGH</strong> = objet détecté</li>
                  <li><strong>LOW</strong> = pas d’objet</li>
                </ul>

                <p>
                  Ce capteur infrarouge est utilisé pour détecter l’arrivée d’une pièce en fin de convoyage et d'arrêter le moteur. 
                </p>

                <div class="image-container">
                  <img src="images/Test4_2/Electronique/circuit_infrared.png" alt="infrared" class="image-mean"/>
                </div>

                <div class="code-container">
                  <p>code_infrarouge.ino </p>
                  <div class="btn-bar">
                    <button onclick="copierCode('code_infrarouge-ino', this)">📋</button>
                    <button onclick="telechargerCode('code_infrarouge-ino', 'code_infrarouge.ino', 'text/ino', this)">🡇</button>
                  </div>
                  <pre><code id="code_infrarouge-ino">
    #define infraredSensor 19

    int infraredValue = 0; //stocke la valeur du capteur infrarouge

    void setup(){
        pinMode(infraredSensor, INPUT);
        Serial.begin(9600);
    }

    void loop(){
        infraredValue = digitalRead(infraredSensor);
        // affichage sur le moniteur
        Serial.print(" Valeur du capteur: ");
        Serial.println(infraredValue);
        delay(500);
    }
                </code></pre>
              </div>

              <h5>&#10022; Le capteur de couleur TCS230/TCS3200</h5>
                <p>
                  Le capteur de couleur TCS230 (ou TCS3200) est un dispositif optique capable de détecter la couleur dominante d’un objet. 
                  Il fonctionne en convertissant l’intensité lumineuse de la couleur perçue en un signal carré dont <strong>la fréquence varie selon la couleur détectée</strong>.
                  Ce capteur est plus fiable et performant que le capteur de couleur 
                  <a href="https://www.mouser.com/datasheet/2/321/28380-ColorPAL-Documentation-370265.pdf?srsltid=AfmBOoqGq8vwQaI62oqMLZm4TdE2iRID73yldqJOA6wBk9wV9HYMWR5j" target="_blank"><strong>ColorPal</strong></a> utilisé initialement.
                </p>
                <ul>
                  &#9673; <strong>Fonctionnement:</strong>
                  <li>
                    Le capteur est composé d'une matrice de 8×8 photodiodes, soit 64 au total: 3x16 photodiodes sensibles au rouge, vert, bleu, et 16 photodiodes sans filtre(blanc). 
                  </li>
                  <li>
                    Les photodiodes sont sélectionnées via les broches <strong>S2</strong> et <strong>S3</strong>, permettant de choisir la composante de couleur à mesurer (R, G ou B).
                  </li>
                  <li>La sortie du capteur est fournie sur la broche <strong>OUT</strong>, sous forme d’un signal carré dont <strong>la fréquence est proportionnelle à l’intensité de la couleur mesurée</strong>.</li>
                </ul>

                <ul>
                  &#9673; <strong>Brochage:</strong>
                  <table border="2" cellspacing="1" cellpadding="6">
                    <thead>
                      <tr>
                        <th>Pin</th>
                        <th>Rôle</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><strong>VCC</strong></td>
                        <td>Alimentation(2.7-5.5V)</td>
                      </tr>
                      <tr>
                        <td><strong>GND</strong></td>
                        <td>Masse</td>
                      </tr>
                      <tr>
                        <td><strong>S0, S1</strong></td>
                        <td>Selection de l'échelle de fréquence de sortie</td>
                      </tr>
                      <tr>
                        <td><strong>S2, S3</strong></td>
                        <td>Selection du type de photodiode</td>
                      </tr>
                      <tr>
                        <td><strong>Out</strong></td>
                        <td>Sortie de fréquence</td>
                      </tr>
                      <tr>
                        <td><strong>OE</strong></td>
                        <td>Activer la sortie(actif bas)</td>
                      </tr>
                    </tbody>
                  </table>
                </ul>

                <ul>
                  &#9673; <strong>Utilisation avec un Arduino:</strong>
                  <li>
                    Lorsqu’un objet est placé devant le capteur, celui-ci mesure la lumière réfléchie par l’objet pour chaque composante de couleur (rouge, vert, bleu).
                  </li>
                  <li>
                    Le capteur envoie ensuite les fréquences mesurées à l’Arduino, qui les analyse pour déterminer la couleur dominante.
                  </li>
                </ul>

                <div class="image-container">
                  <img src="images/Test4_2/Electronique/capteur_couleur.jpg" alt="capteur_couleur" class="image-mean"/>
                </div>
                
                <!-- <div class="image-container">
                  <img src="images/Test4/Electronique/circuit_sensorColor.png" alt="capteur_couleur" class="image-mean"/>
                </div> -->
                
                <div class="code-container">
                  <p>code_tcs230.ino </p>
                  <div class="btn-bar">
                    <button onclick="copierCode('code_tcs230-ino', this)">📋</button>
                    <button onclick="telechargerCode('code_tcs230-ino', 'code_tcs230.ino', 'text/ino', this)">🡇</button>
                  </div>
                  <pre><code id="code_tcs230-ino">
    // Définir les broches du capteur
    #define S0 2
    #define S1 3
    #define S2 4
    #define S3 5
    #define sensorOut 7


    void setup() {
      Serial.begin(9600); // Initialiser la communication série à 9600 bauds
      pinMode(S0, OUTPUT); // Définir S0 comme sortie
      pinMode(S1, OUTPUT); // Définir S1 comme sortie
      pinMode(S2, OUTPUT); // Définir S2 comme sortie
      pinMode(S3, OUTPUT); // Définir S3 comme sortie
      pinMode(sensorOut, INPUT); // Définir sensorOut comme entrée


      // Configurer l'échelle de fréquence à 20%
      digitalWrite(S0, HIGH);
      digitalWrite(S1, LOW);
    }

    void loop() {
      printColorFrequency();
      delay(500); // Attendre 500 ms avant la prochaine lecture
    }

    void printColorFrequency() {
      // Lire la valeur de la couleur rouge
      digitalWrite(S2, LOW); // Activer les photodiodes rouges
      digitalWrite(S3, LOW);
      int redFrequency = pulseIn(sensorOut, LOW); // Lire la fréquence de sortie pour le rouge
      Serial.print("Red: ");
      Serial.print(redFrequency);
      Serial.print("  ");


      // Lire la valeur de la couleur verte
      digitalWrite(S2, HIGH); // Activer les photodiodes vertes
      digitalWrite(S3, HIGH);
      int greenFrequency = pulseIn(sensorOut, LOW); // Lire la fréquence de sortie pour le vert
      Serial.print("Green: ");
      Serial.print(greenFrequency);
      Serial.print("  ");


      // Lire la valeur de la couleur bleue
      digitalWrite(S2, LOW); // Activer les photodiodes bleues
      digitalWrite(S3, HIGH);
      int blueFrequency = pulseIn(sensorOut, LOW); // Lire la fréquence de sortie pour le bleu
      Serial.print("Blue: ");
      Serial.println(blueFrequency);
    }   
                </code></pre>
              </div>             

              <h4>d. Module Wi-Fi ESP01</h4>
                <p>
                  Le module Wi-Fi ESP8266, version ESP-01, permet aux microcontrôleurs de se connecter à un réseau Wi-Fi. 
                  Dans notre projet, il est principalement utilisé pour communiquer avec une <strong>interface web</strong> et transmettre des informations(la couleur detectée et l'état du système).
                </p>
                <p>
                  <h5>&#10022; Configuration de l’IDE Arduino pour l’ESP8266</h5>
                  Pour utiliser l’ESP8266 avec l’IDE Arduino, il faut suivre les étapes suivantes :
                  <ul>
                    <li>Ajouter le support de la carte ESP8266: ajouter l’URL(http://arduino.esp8266.com/stable/package_esp8266com_index.json) de la source ESP8266 dans les préférences de l’IDE</li>
                    <li>Installer le package logiciel: rechercher et installer la bibliothèque <strong>ESP8266</strong></li>
                    <li>Sélectionner la carte: choisir "Generic ESP8266 Module"</li>
                  </ul>
                </p>

                  <h5>&#10022; Brochage de l’ESP-01 (ESP8266-01)</h5>
                  <table border="2" cellspacing="1" cellpadding="6">
                  <thead>
                    <tr>
                      <th></th>
                      <th>Rôles</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><strong>VCC</strong></td>
                      <td>Alimentation(<strong>3.3V</strong>)</td>
                    </tr>
                    <tr>
                      <td><strong>GND</strong></td>
                      <td>Masse</td>
                    </tr>
                    <tr>
                      <td><strong>TX</strong></td>
                      <td>Transmission de données</td>
                    </tr>
                    <tr>
                      <td><strong>RX</strong></td>
                      <td>Réception de données</td>
                    </tr>
                    <tr>
                      <td><strong>CH_PD / EN</strong></td>
                      <td>Activation du module</td>
                    </tr>
                    <tr>
                      <td><strong>Reset</strong></td>
                      <td>Réinitialisation du module</td>
                    </tr>
                    <tr>
                      <td><strong>GPIO0 et GPIO2</strong></td>
                      <td>Broches d’entrée/sortie numériques</td>
                    </tr>
                  </tbody>
                </table>
              <div class="image-container">
                <img src="images/Test4_2/Electronique/module_wifi.jpg" alt="module_wifi" class="image-small"/>
              </div>

              <p class="txt_center">
                <strong>NB:</strong> ce module n'est pas encore intégré dans cette documentation à cause de problèmes de communication avec l'interface.
                La communication se fera alors par cable USB pour le moment.
              </p>

              <h4>e. Bloc de sortie</h4>
              <h5>&#10022; Moteur</h5>
                <p>
                  Le <strong>moteur à courant continu</strong> (DC) 6–12 V est utilisé pour entraîner le tapis du convoyeur. 
                  Il assure le déplacement des objets détectés grâce à son couple adapté aux applications de petite puissance. 
                  Son alimentation est assurée par une source externe(12 V), 
                  tandis que sa mise en marche est commandée électroniquement.
                </p>
                <p>
                  Pour contrôler le moteur, un transistor <strong>MOSFET canal N</strong> est utilisé comme interrupteur électronique. 
                  Ce composant permet de gérer l’alimentation du moteur en fonction du signal envoyé par la carte Arduino. 
                  Une diode de roue libre est placée en parallèle du moteur afin de protéger le circuit contre les surtensions transitoires générées lors de l’arrêt du moteur, dues à l’induction.
                </p>
                <p>
                  La commande du moteur se fait via une broche <strong>PWM</strong> de l’Arduino connectée à la grille du MOSFET. 
                  En faisant varier le rapport cyclique du signal PWM, il est possible d'<strong>ajuster la vitesse de rotation</strong> du moteur, et donc la vitesse du convoyeur. 
                  Un signal à rapport cyclique élevé entraîne une rotation rapide, tandis qu’un rapport plus faible réduit la vitesse du moteur.
                </p>
                <p>
                  Ainsi, le système est plus optimisé et ne dépend plus d'un 
                  <a href="https://www.handsontec.com/dataspecs/L298N%20Motor%20Driver.pdf" download target="_blank">moteur driver</a>.
                </p>

                <div class="image-container">
                  <img src="images/Test4_2/Electronique/mosfet.jpg" alt="Moteur" class="image-small"/>
                  <img src="images/Test4_2/Electronique/moteur_dc.jpg" alt="Moteur" class="image-small"/>
                  <img src="images/Test4_2/Electronique/commande_moteur1.png" alt="Moteur" class="image-mean"/>
                </div>

                <div class="code-container">
                  <p>code_moteur.ino </p>
                  <div class="btn-bar">
                    <button onclick="copierCode('code_moteur-ino', this)">📋</button>
                    <button onclick="telechargerCode('code_moteur-ino', 'code_moteur.ino', 'text/ino', this)">🡇</button>
                  </div>
                  <pre><code id="code_moteur-ino">
    #define pinMotor 3

    void setup () {
        pinMode(pinMotor, OUTPUT);
    }

    void loop() {
        analogWrite(pinMotor, 100);
        delay(2000);
        analogWrite(pinMotor, 0);
        delay(5000);
    }
                </code></pre>
              </div>

              <video controls width=50%>
                <source src="videos/Test4_2/Electronique/moteur1.mp4" type="video/mp4">
                Votre navigateur ne supporte pas la vidéo HTML5.
              </video>

              <h4>&#10022; Led RGB</h4>
                <p>
                  La LED RGB affiche la couleur détectée(rouge, bleu, vert, jaune).
                </p>
                <p>
                  Le signal PWM est utilisé pour moduler l’intensité de chaque couleur et ainsi permettre le mélange des couleurs. 
                  Les broches de la LED doivent donc être connectées à des pins compatibles PWM.
                </p>

                <p>
                  Elle peut aussi indiquer l'état du convoyeur(en marche ou à l'arrêt).
                </p>

                <div class="image-container">
                  <img src="images/Test4_2/Electronique/led.png" alt="LED" class="image-mean"/>
                  <p>Led RGB à anode commun</p>
                </div>

                <div class="image-container">
                  <img src="images/Test4_2/Electronique/circuit_led.png" alt="LED" class="image-mean"/>
                </div>

                <div class="code-container">
                  <p>code_led.ino </p>
                  <div class="btn-bar">
                    <button onclick="copierCode('code_led-ino', this)">📋</button>
                    <button onclick="telechargerCode('code_led-ino', 'code_led.ino', 'text/ino', this)">🡇</button>
                  </div>
                  <pre><code id="code_led-ino">
    #define LED_R 9
    #define LED_G 10
    #define LED_B 11

    void setup() {
      pinMode(LED_R, OUTPUT);
      pinMode(LED_G, OUTPUT);
      pinMode(LED_B, OUTPUT);
    }

    void loop() {
      setColor(100, 0, 0); //rouge
      delay(2000);
      setColor(0, 100, 0); //vert
      delay(2000);
      setColor(0, 0, 100); //bleu
      delay(2000);
      setColor(100, 100, 0); //jaune
      delay(2000);
    }

    void setColor(unsigned int red, unsigned int green, unsigned int blue) {
      red = map(red, 0, 255, 255, 0);
      green = map(green, 0, 255, 255, 0);
      blue = map(blue, 0, 255, 255, 0);
      analogWrite(LED_R, red);
      analogWrite(LED_G, green);
      analogWrite(LED_B, blue);
    }
                </code></pre>
              </div>

              <video controls width=50%>
                <source src="videos/Test4_2/Electronique/led_rgb.mp4" type="video/mp4">
                Votre navigateur ne supporte pas la vidéo HTML5.
              </video>

              <p class="txt_center">
                <strong>NB:</strong> Utiliser des résistances pour protéger la led. 
                Ici, nous avons utilisé des résistances de <strong>270 &ohm;</strong> pour chaque pin RGB.
              </p>

              <h4>f. Bloc de commande</h4>
                <p>
                  Un <strong>interrupteur</strong> a été installé pour permettre à l'utilisateur de mettre sous tension ou de couper le courant.
                </p>
                <p>
                  Par ailleurs, deux <strong>boutons-poussoirs</strong> sont prévus pour commander la mise en marche et l'arrêt du convoyeur.
                  <ul>
                    <li>
                      <strong>Bouton Start</strong>(connecté au pin 7 de l'Arduino): permet d'activer le système.
                    </li>
                    <li>
                      <strong>Bouton Stop</strong>(connecté au pin 2 de l'Arduino): permet de désactiver le système à l'aide 
                      d'<a href="https://docs.arduino.cc/language-reference/en/functions/external-interrupts/attachInterrupt/" download target="_blank">interruption</a>
                      , assurant ainsi un arrêt rapide et réactif.
                    </li>
                  </ul>
                </p>


                <div class="image-container">
                  <img src="images/Test4_2/Electronique/boutons_poussoirs.png" alt="boutons_poussoirs" class="image-mean"/>
                  <p>
                    <strong>NB:</strong> Nous utilisons les résistances 
                    <a href="https://docs.arduino.cc/tutorials/generic/digital-input-pullup/" download target="_blank">pull-up internes</a> 
                    afin d’optimiser l’utilisation du matériel.</p>
                </div>

                <div class="code-container">
                  <p>code_bp.ino </p>
                  <div class="btn-bar">
                    <button onclick="copierCode('code_bp-ino', this)">📋</button>
                    <button onclick="telechargerCode('code_bp-ino', 'code_bp.ino', 'text/ino', this)">🡇</button>
                  </div>
                  <pre><code id="code_bp-ino">
    const byte pinStart = 7;
    const byte pinStop = 2; 
    const byte ledPin = 12;
    volatile bool blinking = false;
    unsigned long lastInterrupt = 0;

    void setup() {
      pinMode(ledPin, OUTPUT);
      // boutons poussoirs
      pinMode(pinStart, INPUT_PULLUP);
      pinMode(pinStop, INPUT_PULLUP);
      attachInterrupt(digitalPinToInterrupt(pinStop), interrupt_routine, FALLING);

      digitalWrite(ledPin, LOW); // éteint la led initialement
    }

    void loop() {
      if(!blinking){
        while(digitalRead(pinStart)){ //tant qu'on n'appuie pas sur btnStart, la boucle continue
          delay(10);
        }
        blinking = true;
      }

      else{
        digitalWrite(ledPin, HIGH);
        delay(300);
        digitalWrite(ledPin, LOW);
        delay(300);
      }
    }

    void interrupt_routine() {
      unsigned long currentMillis = millis();
      if (currentMillis - lastInterrupt > 100) { // anti-rebond de 100 ms
        digitalWrite(ledPin, LOW);
        blinking = false;
        lastInterrupt = currentMillis;
      }
    }
                </code></pre>
              </div>

              <!-- <video controls width=50%>
                <source src="videos/Test4/Electronique/boutons_poussoirs.mp4" type="video/mp4">
                Votre navigateur ne supporte pas la vidéo HTML5.
              </video> -->
              
          <h3 id="4-electro2">4. Tests et validation</h3>
            <p>
              Après avoir pris en main chaque composant, il est temps de réaliser un test global du système électrique.
            </p>
            <p>
              Nous avons réalisé les branchements sur un breadboard puis le circuit sur veroboard pour les tests afin de s'assurer que chaque composant s'integre au système electronique.
            </p>
            <p>Voici quelques uns de ces test:</p>
            <ul>
              <li>Test du capteur de couleur avec la led RGB:</li>
                <video controls width=50%>
                  <source src="videos\Test4_2\Electronique\sensorColor_rgb.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vidéo HTML5.
                </video>

              <li>Vérification de l’alimentation et du pilotage du moteur avec le circuit câblé sur veroboard.</li>
                <video controls width=50%>
                  <source src="videos/Test4_2/Electronique/moteur2.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vidéo HTML5.
                </video>
            </ul>

            
          <h3 id="5-electro2">5. Réalisation du PCB</h3>
            <p>
              Après avoir effectué tous les tests, nous avons réalisé un PCB sur Kicad comme suit:
            </p>
            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb1.png" alt="pcb" class="image-mean" />
              <p>
                Conception du schéma électronique.
              </p>
            </div>

            <p>
              Nous avons décidé par la suite de rassembler les <strong>Vcc</strong> et <strong>GND</strong> pour les capteurs, la led et les boutons poussoirs afin de faciliter les branchements.
            </p>
            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb2.png" alt="pcb" class="image-mean" />
              <p>
                Conception du schéma pour le pcb.
              </p>
            </div>
            
            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb3.png" alt="pcb" class="image-mean" />
              <p>
                Attribution des empreintes.
              </p>
            </div>
        
            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb4.png" alt="pcb" class="image-mean" />
              <p>
                Verificaton des erreurs (DRC)
              </p>
            </div>
            
            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb5.png" alt="pcb" class="image-small" />
              <p>
                Ajustement de la disposition et routage des pistes.
              </p>
            </div>


            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb6.png" alt="pcb" class="image-small" />
              <p>
                Plan de masse GND et ajout des textes pour les différents composants et pins.
              </p>
            </div>

            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb7.png" alt="pcb" class="image-small" />
              <img src="images/Test4_2/Electronique/pcb8.png" alt="pcb" class="image-small" />
              <p>
                Ajout des models 3D(arduino nano et serre-fils).
              </p>
            </div>

            <div class="image-container">
              <img src="images/Test4_2/Electronique/pcb9.png" alt="pcb" class="image-mean" />
              <p>
                Visualisation 3D
              </p>
            </div>

            <p class="txt_center">
              <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/Electronique/convoyeur_pcb.rar" class="download-link">télécharger les fichiers du PCB</a>
            </p>

          <h3 id="6-electro2">6. Prototype final</h3>
            <p>
              Après les tests sur le breadboard et la conception du PCB, il est temps de réaliser le circuit final.
              Nous utilisons ici un veroboard, tout en respectant les pins utilisées dans la conception du PCB.
            </p>
            <p>
              <strong>NB:</strong> Nous avons retravaillé notre circuit pour répondre aux exigences techniques et esthétiques.
            </p>
            <div class="image-container">
              <img src="images\Test4_2\Electronique\circuit0.jpg" alt="circuit" class="image-mean"/>
              <p>
                Comparatif des deux prototypes
              </p>
            </div>

            <div class="image-container">
              <p>
                Prototype final adopté:
              </p>
              <img src="images\Test4_2\Electronique\circuit1.jpg" alt="circuit" class="image-small"/>
              <img src="images\Test4_2\Electronique\circuit5.jpg" alt="circuit" class="image-small"/>
              <img src="images\Test4_2\Electronique\circuit6.jpg" alt="circuit" class="image-small"/>
              <img src="images\Test4_2\Electronique\circuit7.jpg" alt="circuit" class="image-small"/>

              <img src="images\Test4_2\Electronique\circuit2.jpg" alt="circuit" class="image-small"/>
              <img src="images\Test4_2\Electronique\circuit3.jpg" alt="circuit" class="image-small"/>
              <img src="images\Test4_2\Electronique\circuit4.jpg" alt="circuit" class="image-small"/>
              <img src="images\Test4_2\Electronique\circuit9.jpg" alt="circuit" class="image-small"/>
            </div>
        </div>

        <div id="informatique2" class="subtab-content">
          <h2 id="info2" class="projet-titre">Partie informatique</h2>
          <h3 id="1-info2">1. Détection intelligente et automatisation</h3>
            <p>
              La détection intelligente repose sur un système de reconnaissance de couleur embarqué utilisant le capteur <strong>ColorPAL</strong>, piloté par une carte <strong>Arduino Nano</strong>. 
              Ce système a pour mission d’identifier la couleur d’un objet (représentant un type de déchet) à son passage sur un tapis <strong>convoyeur automatisé</strong>.
            </p>
              
            <ul>
              <strong>Détails</strong>
              <li>Initialement, le convoyeur est à l'arrêt.</li>
              <li>
                Un objet(cube) est posé sur le tapis.
              </li>
              <li>
                Le capteur de distance détecte l'objet et le convoyeur démarre grâce au moteur.
              </li>
              <li>
                Lorsque l'objet passe dans la zone de détection, le convoyeur s'arrête et le capteur de couleur s'active pour identifier la couleur de l'objet.
              </li>
              <li>
                Cette couleur, codées sous forme de lettres majuscules (R, G, B, Y, U), est envoyée au serveur Python pour être stockée et publiée sur l'interface web.
              </li>
              <li>La led RGB s'allume suivant la couleur detectée.</li>
              <li>
                Le convoyeur redémarre et ne s'arrête que lorsque l'objet est en bout de course, determiné par un capteur infrarouge à la fin du convoyeur.
              </li>
            </ul>


            <div class="code-container">
              <p>code_convoyeur.ino</p>
              <div class="btn-bar">
                <button onclick="copierCode('code_convoyeur-ino', this)">📋</button>
                <button onclick="telechargerCode('code_convoyeur-ino', 'code_convoyeur.ino', 'text/ino', this)">🡇</button>
              </div>
              <pre><code id="code_convoyeur-ino">
    // boutons marche arrêt & urgence
    #define pinStart 7
    #define pinStop = 2;

    // Contrôle moteur
    #define pinMotor 3

    // Définir les broches du capteur de couleur
    #define LED_R 9
    #define LED_G 10
    #define LED_B 11

    // capteur de couleur
    #define S0 14
    #define S1 15
    #define S2 16
    #define S3 17
    #define Out 18

    // capteur infrarouge
    #define infraredSensor 19

    // capteur Ultrason
    #define trigPin 5
    #define echoPin 6

    unsigned int redFrequency = 0, greenFrequency = 0, blueFrequency = 0, infraredValue = 0;
    const int nbEchantillon = 5;
    unsigned long distance = 0, lastInterrupt = 0;
    char color_detected = 'U';
    bool finTapis = true;
    volatile String state = "OFF";

    void setup()
    {
        pinMode(LED_R, OUTPUT);
        pinMode(LED_G, OUTPUT);
        pinMode(LED_B, OUTPUT);
        setColor(0, 0, 0); // blanc

        // Ultrason
        pinMode(trigPin, OUTPUT);
        pinMode(echoPin, INPUT);

        // Infrarouge
        pinMode(infraredSensor, INPUT);

        // capteur de couleur
        pinMode(S0, OUTPUT);
        pinMode(S1, OUTPUT);
        pinMode(S2, OUTPUT);
        pinMode(S3, OUTPUT);
        pinMode(Out, INPUT);

        // Configurer l'échelle de fréquence à 100%
        digitalWrite(S0, HIGH);
        digitalWrite(S1, HIGH);

        // boutons poussoirs
        pinMode(pinStart, INPUT_PULLUP);
        pinMode(pinStop, INPUT_PULLUP);
        attachInterrupt(digitalPinToInterrupt(pinStop), interrupt_routine, FALLING);

        Serial.begin(9600);
        delay(100);
        Serial.println(state);
    }

    void loop()
    {
        if (state == "OFF")
        {
            analogWrite(pinMotor, 0);
            while (digitalRead(pinStart))
            {
                // clignotement de la led pour indiquer que le système peut être lancé
                setColor(255, 165, 0);
                delay(100);
                setColor(0, 0, 0);
                delay(100);
            }
            state = "ON";
            Serial.println(state);
        }
        else
        {
            // distance de l'objet par rapport au capteur
            distance = getDistance();
            infraredValue = digitalRead(infraredSensor);

            if (infraredValue)
            {
                finTapis = true;
                analogWrite(pinMotor, 0);
            }

            else if (distance < 50 || !finTapis)
            {
                // zone de détection de couleur
                if (9 < distance && distance < 13)
                {
                    finTapis = false;
                    // arrêt du moteur
                    analogWrite(pinMotor, 0);

                    color_detected = getColor(); // detection de couleur

                    Serial.println(color_detected); // envoie de la couleur à l'interface

                    // redemarrage du moteur
                    analogWrite(pinMotor, 100);
                    delay(500);
                }

                analogWrite(pinMotor, 100);
                delay(20);
            }

            else
            {
                // arrêt du moteur
                analogWrite(pinMotor, 0);
            }
        }
    }

    void setColor(unsigned int red, unsigned int green, unsigned int blue)
    {
        red = map(red, 0, 255, 255, 0);
        green = map(green, 0, 255, 255, 0);
        blue = map(blue, 0, 255, 255, 0);
        analogWrite(LED_R, red);
        analogWrite(LED_G, green);
        analogWrite(LED_B, blue);
    }

    void getFrequencyColor()
    {
        redFrequency = 0;
        greenFrequency = 0;
        blueFrequency = 0;

        for (unsigned int i = 0; i < nbEchantillon; i++)
        {
            // Sélectionner filtre rouge
            digitalWrite(S2, LOW);
            digitalWrite(S3, LOW);
            redFrequency += pulseIn(Out, LOW); // Mesure la frequence du rouge

            // Sélectionner filtre vert
            digitalWrite(S2, HIGH);
            digitalWrite(S3, HIGH);
            greenFrequency += pulseIn(Out, LOW); // Mesure la frequence du vert

            // Sélectionner filtre bleu
            digitalWrite(S2, LOW);
            digitalWrite(S3, HIGH);
            blueFrequency += pulseIn(Out, LOW); // Mesure la frequence du bleu
        }
        redFrequency /= nbEchantillon;
        greenFrequency /= nbEchantillon;
        blueFrequency /= nbEchantillon;
        /*
            // Afficher les valeurs pour la configuration
            Serial.print("R:");
            Serial.print(redFrequency);
            Serial.print(" G:");
            Serial.print(greenFrequency);
            Serial.print("B:");
            Serial.println(blueFrequency);
        */
    }

    char getColor()
    {
        setColor(0, 0, 0);
        getFrequencyColor();

        if (redFrequency > 25 && greenFrequency > 30 && blueFrequency > 25)
        {
            setColor(50, 50, 50);
            return 'U'; // Pas de couleur détectée
        }

        if (redFrequency < 15)
        {
            int diffRG = greenFrequency - redFrequency; // Calculer la différence entre vert et rouge

            if (diffRG < 5)
            {
                setColor(100, 100, 0); // jaune
                return 'Y';
            }
            else if (diffRG >= 5)
            {
                setColor(100, 0, 0); // rouge
                return 'R';
            }
        }
        else if (greenFrequency < redFrequency && greenFrequency < blueFrequency && greenFrequency < 20)
        {                        // Si vert dominant et faible
            setColor(0, 100, 0); // vert
            return 'G';
        }
        else if (blueFrequency < redFrequency && blueFrequency < greenFrequency && blueFrequency < 20)
        {
            setColor(0, 0, 100); // bleu
            return 'B';
        }
        else
        {
            setColor(50, 50, 50);
            return 'U';
        }
    }

    // Fonction pour lire la distance avec le capteur ultrason
    long getDistance()
    {
        digitalWrite(trigPin, LOW);
        delayMicroseconds(2);
        digitalWrite(trigPin, HIGH);
        delayMicroseconds(10);
        digitalWrite(trigPin, LOW);

        long duration = pulseIn(echoPin, HIGH);
        long distance = (duration / 2.0) * 0.0344;
        return distance;
    }

    void interrupt_routine()
    {
    }

    void interrupt_routine()
    {
        unsigned long currentMillis = millis();
        if (currentMillis - lastInterrupt > 50)
        { // anti-rebond de 50 ms
            // arrêt moteur
            analogWrite(pinMotor, 0);
            state = "OFF";
            Serial.println(state);
        }
    }
              </code></pre>
            </div>

            <p class="txt_center">
              <strong>NB:</strong> Les commentaires expliquent en détail le code.
            </p>
            

          <h3 id="2-info2">2. Interface Web</h3>
            <p>
              L’interface web du projet <strong>Convoyeur Intelligent</strong> permet la visualisation en temps réel des données reçues du capteur de couleurs Arduino. 
              Elle affiche les compteurs de déchets selon leur couleur (Rouge, Vert, Bleu, Jaune, Inconnu).
              L’interface facilite le suivi du tri des déchets automatisé sur le convoyeur.
            </p>
            <h4>Fonctionnalités principales</h4>
              <h5>a. Tableau de bord</h5>
                <div class="image-container">
                  <img src="images/Test4_2/IT/web1.png" alt="web" class="image-mean"/>
                </div>
                
                <ul>
                  Informations sur le système:           
                  <li>Etat du système(actif/inactif): permet de savoir si le système est en marche ou non.</li>
                  <li>Taux de détection: permet un suivi du taux d'objet trié sans erreur(inconnu).</li>
                  <li>Nombre total des déchets trié dans le système: donne une idée sur la quantité triée.</li>
                  <li>Le dernier dechet tri: renseigne le dernier dechet par le système.</li>
                  <li>Animation d'un convoyeur: permet une visualiser les objets entrant(avec leur couleur respective).</li>
                </ul>

                <ul>Le nombre de dechets par catégorie:
                  <li>Visualisation représentative de chaque type de déchet.</li>
                  <li>Visualisation en temps réel du nombre de déchets par catégorie.</li>
                </ul>
                
              <h5>b. Historiques des déchets</h5>
                <div class="image-container">
                  <img src="images/Test4_2/IT/web2.png" alt="web" class="image-mean"/>
                </div>
                <ul>
                  <li>Journal détaillé de toutes les détections d’objets triés, avec horodatage, type et couleur</li>
                  <li>Permet de consulter les événements passés pour analyse ou vérification.</li>
                  <li>Export de l'historique en fichier <strong>.csv</strong> pour analyse plus pousée.</li>            
                </ul>

              <h5>c. Statistiques</h5>
                <div class="image-container">
                  <img src="images/Test4_2/IT/web3.png" alt="web" class="image-mean"/>
                </div>
                <ul>
                  <li>Affiche la repartition de chaque catégorie de déchets.</li>
                  <li>Export des statistiques en fichier <strong>.csv</strong> pour des analyses.</li>  
                  <li>Export des statistiques en image pour des publications, ...</li>            
                </ul>

              <h5>d. Paramètres</h5>
                <div class="image-container">
                  <img src="images/Test4_2/IT/web4.png" alt="web" class="image-mean"/>
                  <img src="images/Test4_2/IT/web5.png" alt="web" class="image-mean"/>
                </div>
                <ul>
                  <li>Choix de thème: clair(par défaut)/sombre</li>
                  <li>Choix de langue: Français(par défaut)/Anglais</li>
                  <li>Réinitialisation de la base de données: supprimer l'ensemble des données</li>
                </ul>


          <h3 id="3-info2">3. Architecture technique</h3>
            <p>
              Voici l'arborescence du dossier
            </p>
            <div class="arbo">
              <ul>
                <li class="folder">convoyeur_web
                  <ul>
                    <li class="folder">__pycache</li>
                    <li class="folder">data
                      <ul>                        
                        <li class="file">historique.json</li>
                      </ul>
                    </li>
                    <li class="folder">static
                      <ul>                        
                        <li class="file">script.js</li>
                        <li class="file">style.css</li>
                        <li class="file">tekbot_logo.png</li>
                        <li class="file">trc.png</li>
                      </ul>
                    </li>
                    <li class="folder">templates
                      <ul>                        
                        <li class="file">index.html</li>
                      </ul>
                    </li>
                    <li class="folder">venv</li>
                    <li class="file">app.py</li>
                  </ul>
                </li>
              </ul>
            </div>

            <h4> a. Backend (Serveur Flask + SocketIO)</h4>
              <p>Nous utilisons <strong>python</strong> avec ces librairies.</p>
              <ul>
                <li>
                  Connexion série avec l’Arduino(via <strong>serial</strong>) pour recevoir les données (lettres représentant couleurs, état du système(ON/OFF)).
                </li>
                <li>
                  Traitement, mise à jour et enregistrement des données(via <strong>json, os, ...</strong>).
                </li>
                <li>
                  Emission d’événements WebSocket(via <strong>flask, SocketIO</strong>) pour mise à jour instantanée côté client.
                </li>
              </ul>

              <div class="code-container">
                <p>app.py</p>
                <div class="btn-bar">
                  <button onclick="copierCode('app-py', this)">📋</button>
                  <button onclick="telechargerCode('app-py', 'app.py', 'text/py', this)">🡇</button>
                </div>
                <pre><code id="app-py">  
    from flask import Flask, render_template, jsonify, request
    from flask_socketio import SocketIO, emit
    import threading
    import time
    from datetime import datetime
    import json, os
    from collections import Counter
    import serial.tools.list_ports

    app = Flask(__name__)
    app.secret_key = "tekbot2025"

    # Configuration SocketIO
    socketio = SocketIO(app,
                        cors_allowed_origins="*",
                        async_mode="threading",
                        logger=False,
                        engineio_logger=False)

    # Chemins
    DATA_FOLDER = "data"
    HISTORIQUE_PATH = os.path.join(DATA_FOLDER, "historique.json")

    # Variables globales
    state = "OFF"
    COLOR = ["rouge", "jaune", "bleu", "vert", "inconnu"]

    COULEUR_TYPE = {
        "bleu": "recyclables",
        "jaune": "plastiques",
        "rouge": "dangereux",
        "vert": "organiques",
        "inconnu": "inconnu" 
    }

    # Initialisation dossier et fichier
    if not os.path.exists(DATA_FOLDER):
        os.mkdir(DATA_FOLDER)
    if not os.path.exists(HISTORIQUE_PATH):
        with open(HISTORIQUE_PATH, "w") as f:
            json.dump([], f)

    # Chargement historique
    try:
        with open(HISTORIQUE_PATH, "r") as f:
            historique = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        historique = []
        with open(HISTORIQUE_PATH, "w") as f:
            json.dump(historique, f)

    # Sauvegarde d’un déchet dans l’historique
    def save_historique(couleur):
        type_dechet = COULEUR_TYPE.get(couleur.lower(), 'inconnu')
        entry = {
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "type": type_dechet,
            "color": couleur
        }
        historique.append(entry)
        with open(HISTORIQUE_PATH, "w", encoding="utf-8") as f:
            json.dump(historique, f, ensure_ascii=False, indent=2)
        return entry

    # Génère les données à transmettre
    def generer_data():
        counts = Counter(entry["color"] for entry in historique)
        compteurs = {c: counts.get(c, 0) for c in COLOR}    
        
        
        total = sum(compteurs.values())
        dernier = historique[-1]["color"] if historique else None

        # Calcul du taux : proportion des couleurs détectées différentes de "inconnu"
        inconnu_count = compteurs.get("inconnu", 0)
        detected_count = total - inconnu_count

        # taux = (detected_count/total)*100 if total > 0 else 0
        taux = round((detected_count / total) * 100, 2) if total > 0 else 0

        return {
            "compteurs": compteurs,
            "total": total,
            "taux": taux,
            "dernier": dernier,
            "historique": historique,
            "etat_systeme": state
        }
        
    # Envoie les données via WebSocket
    def broadcast_data():
        data = generer_data()
        socketio.emit("update_data", data)

    @app.route('/')
    def index():
        return render_template("index.html")

    # Route pour lecture des données
    @app.route('/data')
    def get_data():
        data = generer_data()
        socketio.emit("update_data", data)
        return jsonify(data)

    # Route pour ajouter un déchet
    @app.route('/add', methods=["POST"])
    def add_dechet():
        data = request.get_json()
        couleur = data.get("type")
        
        if couleur not in {"red", "yellow", "blue", "green", "inconnu"}:
            return jsonify({"error": "Type invalide"}), 400

        save_historique(couleur)
        broadcast_data()
        return jsonify({"success": True})

    # Réinitialiser la base de données
    @app.route('/reset', methods=["POST"])
    def reset_data():
        historique.clear()
        with open(HISTORIQUE_PATH, "w") as f:
            json.dump([], f)
        broadcast_data()
        return jsonify({"success": True})

            
    @socketio.on('connect')
    def handle_connect():
        emit('update_data', generer_data())
        
    arduino = None
    arduino_connected = False
    selected_port = None

    def select_port():
        global selected_port
        ports = serial.tools.list_ports.comports()
        ports_list = [port.device for port in ports]
        
        if not ports_list:
            print("Aucun port détecté.")
            exit()
            
        print("Ports disponibles :")
        for port in ports:
            print(str(port))
                
        try:
            choice = int(input("Select Com Port for arduino: "))
            for i in range(len(ports_list)):
                if(ports_list[i].startswith("COM" + str(choice))):
                    selected_port = "COM" + str(choice)
                    print(f"Selected port: {selected_port}")
                    break
            
            if selected_port is None:
                print("Port invalide.")
                exit()

        except ValueError:
            print("Entrée invalide.")
            exit()


    def connect_arduino():
        select_port()
        global arduino, arduino_connected, selected_port
        
        try:
            arduino = serial.Serial(selected_port, 9600)
            arduino_connected = True
            print("Connexion Arduino réussie")
            socketio.emit('notification', {'message': 'Arduino connecté'})
            time.sleep(1)

            
        except Exception as e:
            print(f"Échec connexion Arduino: {e}")
            arduino_connected = False
            socketio.emit('notification', {
                        'message': f'Échec connexion Arduino: {e}'})


    def lecture_arduino():
        while arduino_connected:
            if arduino.in_waiting:
                try:
                    data = arduino.readline().decode().strip()
                    if not data:
                        continue

                    print(f"[Arduino] => {data}")

                    if data in ['R', 'G', 'B', 'Y', 'U']:
                        mapping = {"R": "rouge", "Y": "jaune", "B": "bleu", "G": "vert", "U": "inconnu"} 
                        type_ = mapping[data]
                        save_historique(type_)
                        broadcast_data()
                    
                    elif data in ["ON", "OFF"]:
                        global state
                        state = data
                        broadcast_data()
                        

                except Exception as e:
                    print(f"Erreur lecture Arduino: {e}")
                    time.sleep(0.5)

            time.sleep(0.1)


    # Lancement
    if __name__ == '__main__':
        connect_arduino()

        if arduino_connected:
            thread = threading.Thread(target=lecture_arduino)
            thread.daemon = True
            thread.start()

        socketio.run(app, host='0.0.0.0', port=5000,
                    debug=False, allow_unsafe_werkzeug=True)
                </code></pre>
              </div>

              <h4>b. Frontend (HTML, CSS, JavaScript avec Socket.IO)</h4>
                <ul>
                  <li>Affichage dynamique des données reçues via WebSocket.</li>
                  <li>Mises à jour en temps réel(avec temps de communication avec les différents éléments).</li>
                  <li>Animation simple du convoyeur.</li>
                </ul>

                  <div class="code-container">
                    <p>index.html</p>
                    <div class="btn-bar">
                      <button onclick="copierCode('index-html', this)">📋</button>
                      <button onclick="telechargerCode('index-html', 'index.html', 'text/html', this)">🡇</button>
                    </div>
                    <pre><code id="index-html">
    &lt;!DOCTYPE html&gt;
    &lt;html lang="fr"&gt;
    &lt;head&gt;
      &lt;meta charset="UTF-8"&gt;
      &lt;title&gt;Système de Tri Intelligent - B2MS&lt;/title&gt;
      &lt;link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}"&gt;
      &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"&gt;
      &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;/head&gt;

    &lt;body&gt;
      &lt;header&gt;
        &lt;img class="left-logo" src="{{ url_for('static', filename='trc.png') }}" alt="Logo gauche"&gt;
        
        &lt;div class="header-center"&gt;
          &lt;h1&gt;Système de Tri Intelligent - Convoyeur&lt;/h1&gt;
          &lt;h2&gt;B2MS CleanTech&lt;/h2&gt;
        &lt;/div&gt;
        
        &lt;img class="right-logo" src="{{ url_for('static', filename='tekbot_logo.png') }}" height="10" alt="Logo droite"&gt;
      &lt;/header&gt;

      &lt;nav&gt;
        &lt;button class="tab-btn active" data-target="dashboard"&gt;Tableau de bord&lt;/button&gt;
        &lt;button class="tab-btn" data-target="historique"&gt;Historique&lt;/button&gt;
        &lt;button class="tab-btn" data-target="statistiques"&gt;Statistiques&lt;/button&gt;
        &lt;button class="tab-btn" data-target="parametres"&gt;Paramètres&lt;/button&gt;
      &lt;/nav&gt;

      &lt;main&gt;
        &lt;!-- Tableau de bord --&gt;
        &lt;section id="dashboard" class="active"&gt;
          &lt;div class="dashboard-container"&gt;
            &lt;div class="left-column"&gt;
              &lt;div class="system-info"&gt;
                &lt;p&gt;&lt;strong&gt;État :&lt;/strong&gt; &lt;span id="etat-systeme"&gt;🔴 Inactif&lt;/span&gt;&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Total déchets traités :&lt;/strong&gt; &lt;span id="total-dechets"&gt;0&lt;/span&gt;&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Taux de detection :&lt;/strong&gt; &lt;span id="taux-detection"&gt;0%&lt;/span&gt;&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Dernier déchet détecté :&lt;/strong&gt; &lt;span id="dernier-dechet"&gt;N/A&lt;/span&gt;&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="conveyor-wrapper"&gt;
              &lt;div class="conveyor-container"&gt;
                &lt;div class="belt"&gt;
                  &lt;div id="pattern" class="pattern"&gt;&lt;/div&gt;
                &lt;/div&gt;
                &lt;div id="detected-object" class="detected-object"&gt;&lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="tubes"&gt;
            &lt;div class="tube red"&gt;
              &lt;div class="icon"&gt;☣️&lt;/div&gt;
              &lt;div&gt;Dangereux&lt;/div&gt;
              &lt;div class="count" id="count-red"&gt;0&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="tube yellow"&gt;
              &lt;div class="icon"&gt;📦&lt;/div&gt;
              &lt;div&gt;Plastiques/Cartons&lt;/div&gt;
              &lt;div class="count" id="count-yellow"&gt;0&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="tube blue"&gt;
              &lt;div class="icon"&gt;♻️&lt;/div&gt;
              &lt;div&gt;Recyclables&lt;/div&gt;
              &lt;div class="count" id="count-blue"&gt;0&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="tube green"&gt;
              &lt;div class="icon"&gt;🍃&lt;/div&gt;
              &lt;div&gt;Biodégradables&lt;/div&gt;
              &lt;div class="count" id="count-green"&gt;0&lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;

        &lt;!-- Historique --&gt;
        &lt;section id="historique"&gt;
          &lt;button id="exportBtn"&gt;Exporter CSV&lt;/button&gt;
          &lt;table&gt;
            &lt;thead&gt;
              &lt;tr&gt;
                &lt;th&gt;Chronologie&lt;/th&gt;
                &lt;th&gt;Type&lt;/th&gt;
                &lt;th&gt;Couleur&lt;/th&gt;
              &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody id="historyBody"&gt;
            &lt;/tbody&gt;
          &lt;/table&gt;
        &lt;/section&gt;

        &lt;!-- Statistiques --&gt;
        &lt;section id="statistiques" class="container"&gt;
          &lt;div id="statsContainer"&gt;
            &lt;canvas id="pieChart"&gt;&lt;/canvas&gt;
            &lt;button id="downloadChart"&gt;Télécharger Graphique&lt;/button&gt;
            &lt;button id="exportStatsCsv"&gt;Exporter Statistiques CSV&lt;/button&gt;
          &lt;/div&gt;
        &lt;/section&gt;

        &lt;!-- Paramètres --&gt;
        &lt;section id="parametres" class="container"&gt;
          &lt;div id="theme-switcher" class="sub-container"&gt;
            &lt;h1&gt;Thème :&lt;/h1&gt;
            &lt;button id="lightThemeBtn" class="active"&gt;Clair&lt;/button&gt;
            &lt;button id="darkThemeBtn"&gt;Sombre&lt;/button&gt;
          &lt;/div&gt;

          &lt;div id="language-switcher" class="sub-container"&gt;
            &lt;h1&gt;Langue :&lt;/h1&gt;
            &lt;button id="frBtn" class="active"&gt;Français&lt;/button&gt;
            &lt;button id="enBtn"&gt;English&lt;/button&gt;
          &lt;/div&gt;
          &lt;div class=" sub-container"&gt;
            &lt;h1&gt;Base de données :&lt;/h1&gt;
            &lt;button id="resetCountersBtn"&gt;🔄 Réinitialiser&lt;/button&gt;
          &lt;/div&gt;
        &lt;/section&gt;

      &lt;/main&gt;

      &lt;footer&gt;
        Copyright © 2025 Team B2MS CleanTech. All rights reserved.
      &lt;/footer&gt;
      
      &lt;canvas id="pieChart"&gt;&lt;/canvas&gt;
      &lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;
      &lt;script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"&gt;&lt;/script&gt;
      &lt;script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"&gt;&lt;/script&gt;
      &lt;script src="https://cdn.socket.io/4.7.2/socket.io.min.js"&gt;&lt;/script&gt;
      &lt;script src="{{ url_for('static', filename='script.js') }}"&gt;&lt;/script&gt;

    &lt;/body&gt;
    &lt;/html&gt;
                    </code></pre>
                  </div>

                <div class="code-container">
                  <p>style.css</p>
                  <div class="btn-bar">
                    <button onclick="copierCode('style-css', this)">📋</button>
                    <button onclick="telechargerCode('style-css', 'style.css', 'text/css', this)">🡇</button>
                  </div>
                  <pre><code id="style-css">
    @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap");

    :root {
      --primary-color: #00796b;
      --primary-color-dark: #009572;
      --primary-color-under-ligne: #ffffff;
      --text-dark: #0c0a09;
      --text-light: #78716c;
      --white: #ffffff;
      --max-width: 1200px;
      --redLight: #ff4c4c;
      --yellowLight: #fbc02d;
      --greenLight: #388e3c;
      --blueLight: #1976d2;
      
      --gris-clair: #f8f9fa;
      --gris-fonce: #212529;
      --noir: #000000;

      --transition: all 0.3s ease;
    }

    * {
      padding: 0;
      margin: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #ffffff;
      color: black;
      line-height: 1.6;
    }

    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      font-weight: bold;
      font-size: 1.2rem;
      background-color: #ffffff;
    }

    .header-center {
      text-align: center;
      flex-grow: 1;
    }

    .left-logo {
      width: 15%;
      height: auto;
      margin-right: 1rem;
    }

    .right-logo {
      width: 5%;
      height: auto;
      margin-left: 1rem;
    }

    header h1 {
      color: var(--primary-color);
    }

    header h4 {
      color: var(--primary-color);
    }

    .container {
      border-radius: 12px;
      max-width: 1000px;
      align-items: center; 
      margin: auto;
      width: 100%;         
      border: 2px solid #cce4d8;
      background-color: var(--blanc);
      padding: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      margin-top: -0.5rem !important;
      justify-content: center !important;
      align-items: center !important;
    }

    .sub-container {
      align-items: center; 
      border: 2px solid #cce4d8;
      background-color: #f8fbfa;
      padding: 0.5rem;
      margin-bottom: 2rem;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }


    /* Nav */
    nav {
      display: flex;
      background: #e0f2f1;
    }

    nav button {
      flex: 1;
      padding: 1rem;
      background: #e0f2f1;
      border: none;
      border-top: none; 
      margin: 0;         
      outline: none;     
      color: #00796b;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2rem;
      transition: background 0.3s;
    }


    nav button.active,
    nav button:hover {
      background: #b2dfdb;
    }

    /* Main */
    main {
      padding: 1rem;
    }

    section {
      display: none;
    }

    section.active {
      display: block;
    }

    .dashboard-container {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 1rem;
      align-items: start;
    }

    .left-column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .conveyor-wrapper {
      display: flex;
      justify-content: center;
      margin: 1.5rem;
    }

    /* Bande animée du convoyeur */
    .conveyor-container {
      width: 300px;
      height: 120px;
      background-color: #f8fbfa;
      color: #333;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
      border-radius: 8px;
    }

    .belt {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 30px;
      overflow: hidden;
    }

    .pattern {
      width: 200%;
      height: 100%;
      background: linear-gradient(90deg, #777 25%, #bbb 50%, #777 75%);
      background-size: 100px 30px;
      /* animation: scrollBelt 6s linear infinite; */
    }

    .pattern.moving {
      animation: scrollBelt 6s linear infinite;
    }

    @keyframes scrollBelt {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%);
      }
    }

    .detected-object {
      width: 40px;
      height: 40px;
      border-radius: 4px;
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background-color: transparent;
      opacity: 0;
      pointer-events: none;
      transition: background-color 0.3s ease, opacity 0.3s ease;
    }

    .detected-object.active {
      opacity: 1;
    }


    .system-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      padding: 1.5rem;
      margin: 1rem auto;
      width: 100%;
      background-color: #f8fbfa;
      color: #333;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      font-size: 1.2rem;
    }

    .system-info p {
      margin: 0;
      padding: 0.3rem 0;
    }

    .system-info strong {
      color: #222;
    }

    .system-info span {
      font-weight: bold;
      color: #0b6f6a;
    }


    /* Dashboard tubes */
    .tubes {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      justify-content: center;
    }

    .tube {
      flex: 1;
      background: white;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);
      text-align: center;
      position: relative;
    }

    .tube .icon {
      font-size: 3rem;
      margin-bottom: 0.5rem;
    }

    .tube .count {
      font-size: 2rem;
      font-weight: bold;
    }

    .tube.red {
      background: #ffdddd;
      border: 2px solid #ff4c4c;
      color: var(--redLight);
    }

    .tube.yellow {
      background: #fff8cc;
      border: 2px solid #ffcc00;
      color: var(--yellowLight);
    }

    .tube.blue {
      background: #ddeeff;
      border: 2px solid #3399ff;
      color: var(--blueLight);
    }

    .tube.green {
      background: #ddffdd;
      border: 2px solid #33cc33;
      color: var(--greenLight);
    }

    /* Buttons général */
    button {
      margin-top: 1rem;
      background: #26A69A;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
      border-radius: 4px;
      font-weight: 600;
      transition: background-color 0.3s;
    }

    button:hover {
      background: #42A5F5;
    }

    /* Historique */
    table {
      width: 90%;
      border-collapse: collapse;
      margin-left: auto;
      margin-right: auto;
      margin-top: 1rem;
    }

    th,
    td {
      padding: 0.5rem;
      border: 1px solid #ccc;
      text-align: center;
    }

    th {
      background: #eee;
    }

    /* Statistiques */
    #statsContainer {
      max-width: 400px;
      margin: auto;
      text-align: center;
    }

    #downloadChart{
      margin-top: 1rem; 
      margin-bottom: 1rem
    }

    #pieChart {
      max-width: 100%;
      height: auto;
    }

    /* Paramètres */
    #parametres {
      text-align: center;
      /* margin-top: 2rem; */
      font-family: Arial, sans-serif;
    }

    /* Label-like buttons "Mode :", "Langue :" */
    .text-btn {
      background: none;
      border: none;
      cursor: default;
      color: inherit;
      font-weight: bold;
      user-select: none;
      font-size: 1.2rem;
      padding: 0 0.5rem 0 0;
      display: flex;
      align-items: center;
    }

    /* Groupes de boutons (thème, langue) */
    .theme-switcher,
    .language-switcher {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      margin: 1rem 0 1.5rem;
      font-size: 1.1rem;
      color: inherit;
    }

    #parametres button {
      padding: 0.5rem 1.2rem;
      border: none;
      border-radius: 8px;
      background-color: var(--theme-btn-bg, #e0e0e0);
      color: var(--theme-btn-text, #333);
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
      font-size: 1rem;
      user-select: none;
      min-width: 80px;
    }


    #parametres button:hover:not(.active) {
      background-color: var(--theme-btn-hover, #ccc);
      color: var(--theme-btn-text-hover, #000);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    }

    #parametres button.active {
      background-color: var(--theme-btn-active, #26a69a);
      color: var(--theme-btn-active-text, #fff);
      cursor: default;
      pointer-events: none;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Bouton réinitialiser compteurs */
    #resetCountersBtn {
      padding: 0.7rem 1.5rem;
      font-size: 1.1rem;
      background-color: #e53935 !important;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-top: 1rem;
    }

    #resetCountersBtn:hover {
      background-color: #c62828 !important;
    }

    footer{
      text-align: center;
      font-size: 1.2rem;
    }




    /* Thème clair par défaut */
    body.light-theme {
      background: #f0f2f5;
      color: #333;
    }

    /* Thème sombre */
    body.dark-theme {
      background: #121212;
      color: #eee;
    }

    /* Ajustements mode sombre */
    body.dark-theme header {
      background: #222;
      color: #fff;
    }

    body.dark-theme nav {
      background: #333;
    }

    body.dark-theme nav button {
      background: #333;
      color: #bbb;
    }

    body.dark-theme nav button.active,
    body.dark-theme nav button:hover {
      background: #093d38;
      color: white;
    }

    body.dark-theme .tube {
      background: #222;
      color: #eee;
      box-shadow: 0 2px 8px rgb(255 255 255 / 0.1);
      border-color: #555;
    }

    body.dark-theme .tube.red {
      background: #1a0000; 
      color: #ff4c4c;
      border-color: #ff4c4c;
      box-shadow: inset 0 0 15px 5px #ff4c4c80;
    }

    body.dark-theme .tube.yellow {
      background: #332a00;
      color: #ffcc00;
      border-color: #ffcc00;
      box-shadow: inset 0 0 15px 5px #ffcc0080;
    }

    body.dark-theme .tube.blue {
      background: #001a33; 
      color: #3399ff;
      border-color: #3399ff;
      box-shadow: inset 0 0 15px 5px #3399ff80;
    }

    body.dark-theme .tube.green {
      background: #003300; 
      color: #33cc33;
      border-color: #33cc33;
      box-shadow: inset 0 0 15px 5px #33cc3380; 
    }


    body.dark-theme th {
      background: #2a2929;
    }

    body.dark-theme button {
      background: #607D8B;
      color: white;
    }

    body.dark-theme button:hover {
      background: #455A64;
    }




    body.dark-theme #parametres button.active {
      background-color: var(--theme-btn-active, #01655b);
    }

    body.dark-theme #resetCountersBtn {
      background-color: #e53935 !important; /* rouge vif */
      color: #fff;
      box-shadow: 0 0 5px rgba(229, 57, 53, 0.3);
    }

    body.dark-theme #resetCountersBtn:hover {
      background-color: #c62828 !important; /* rouge plus foncé */
      color: #fff;
      box-shadow: 0 0 8px rgba(198, 40, 40, 0.4);
    }


    body.dark-theme h {
      color: #fff;
    }

    body.dark-theme .container {       
      border: 2px solid #2a2d34;
      background-color:  #1e1e1e;
      box-shadow: 0 2px 8px rgba(255,255,255,0.05);
    }

    body.dark-theme .sub-container {
      border: 2px solid #31353e;
      background-color: #1e1f24; 
      box-shadow: 0 2px 8px rgba(255,255,255,0.05);
    }



    body.dark-theme .system-info {
      background-color: #1e1e1e;
      color: #ddd;
      box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
    }

    body.dark-theme .system-info strong {
      color: #fff;
    }

    body.dark-theme .system-info span {
      color: #90caf9; /* bleu clair pour contraster */
    }

    body.dark-theme .conveyor-container {
      background-color: #1e1e1e;
      color: #ddd;
      box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
    }




    /* Dashboard responsive : une seule colonne sous 768px */
    @media (max-width: 768px) {
      .dashboard-container {
        grid-template-columns: 1fr;
      }

      .tubes {
        flex-direction: column;
        gap: 1rem;
      }

      .tube {
        width: 100%;
      }

      .conveyor-container {
        width: 100%;
        height: 100px;
      }

      .detected-object {
        width: 30px;
        height: 30px;
      }

      table {
        font-size: 0.85rem;
        width: 100%;
      }

      th, td {
        padding: 0.4rem;
      }

      #statsContainer {
        max-width: 100%;
        padding: 0 1rem;
      }

      .container,
      .sub-container {
        padding: 1rem;
        margin: 1rem;
      }

      .system-info {
        grid-template-columns: 1fr;
        font-size: 1rem;
      }
    }

    /* Header responsive sous 600px */
    @media (max-width: 600px) {
      header {
        flex-direction: column;
        text-align: center;
      }

      .left-logo,
      .right-logo {
        width: 50px;
        margin: 0.5rem auto;
      }

      .header-center {
        margin: 0.5rem 0;
      }

      nav {
        flex-direction: column;
      }

      nav button {
        font-size: 1rem;
        padding: 0.8rem;
      }
    }

    /* Paramètres responsive sous 500px */
    @media (max-width: 500px) {
      .theme-switcher,
      .language-switcher {
        flex-direction: column;
        gap: 0.5rem;
      }

      #parametres button {
        min-width: unset;
        width: 100%;
      }
    }
                  </code></pre>
                </div>

                <div class="code-container">
                  <p>script.js</p>
                  <div class="btn-bar">
                    <button onclick="copierCode('script-js', this)">📋</button>
                    <button onclick="telechargerCode('script-js', 'script.js', 'text/js', this)">🡇</button>
                  </div>
                  <pre><code id="script-js">
    let hasInitialized = false;

    // Gestion des onglets
    const tabs = document.querySelectorAll('.tab-btn');
    const sections = document.querySelectorAll('main section');

    const DELAI_ANIM = 3000;

    // Données système
    let systemActif = false;
    let totalCount = 0;
    const counts = {red: 0, yellow: 0, blue: 0, green: 0, inconnu: 0};
    const countElems = {
      red: document.getElementById('count-red'),
      yellow: document.getElementById('count-yellow'),
      blue: document.getElementById('count-blue'),
      green: document.getElementById('count-green')
    };

    const totalElem = document.getElementById('total-dechets');
    const dernierDechetElem = document.getElementById('dernier-dechet');
    const etatElem = document.getElementById('etat-systeme');

    const detectedObjectElem = document.getElementById('detected-object');
    const conveyorState = document.getElementById('pattern');

    const history = [];
    let currentLang = localStorage.getItem('lang') || 'fr';

    const translations = {
      fr: {
        modeLabel: "Thème :",
        languageLabel: "Langue :",
        resetBtn: "Réinitialiser la base de données",
        exportBtn: "Exporter CSV",
        downloadChart: "Télécharger Graphique",
        exportStatsCsv: "Exporter Statistiques CSV",
        tubes: {
          red: "Dangereux",
          yellow: "Plastiques/Cartons",
          blue: "Recyclables",
          green: "Biodégradables",
          unknown: "Inconnu" 
        },
        tabs: ["Tableau de bord", "Historique", "Statistiques", "Paramètres"],
        title: "Système de Tri Intelligent - Convoyeur",
        unknown: "Inconnu",
        system: {
          state: "État",
          total: "Total déchets traités",
          taux: "Taux de detection",
          last: "Dernier déchet détecté",
          on: "Actif",
          off: "Inactif"
        }
      },
      en: {
        modeLabel: "Theme:",
        languageLabel: "Language:",
        resetBtn: "Reset Database",
        exportBtn: "Export CSV",
        downloadChart: "Download Chart",
        exportStatsCsv: "Export Stats CSV",
        tubes: {
          red: "Hazardous",
          yellow: "Plastics/Cartons",
          blue: "Recyclables",
          green: "Biodegradable",
          unknown: "Unknown"
        },
        tabs: ["Dashboard", "History", "Statistics", "Settings"],
        title: "Smart Sorting System - Conveyor",
        unknown: "Unknown",
        system: {
          state: "State",
          total: "Total Waste Processed",
          taux: "Detection rate",
          last: "Last Detected Waste",
          on: "Active",
          off: "Inactive"
        }
      }
    };


    function switchLang(lang) {
      currentLang = lang;
      localStorage.setItem('lang', lang);

      // Traduction onglets
      tabs.forEach((tab, idx) => {
        tab.textContent = translations[lang].tabs[idx];
      });

      // Traduction tubes
      document.querySelector('.tube.red div:nth-child(2)').textContent = translations[lang].tubes.red;
      document.querySelector('.tube.yellow div:nth-child(2)').textContent = translations[lang].tubes.yellow;
      document.querySelector('.tube.blue div:nth-child(2)').textContent = translations[lang].tubes.blue;
      document.querySelector('.tube.green div:nth-child(2)').textContent = translations[lang].tubes.green;

      // Autres traductions
      document.querySelector('.header-center h1').textContent = translations[lang].title;
      document.getElementById('resetCountersBtn').textContent = translations[lang].resetBtn;
      document.getElementById('exportBtn').textContent = translations[lang].exportBtn;
      document.getElementById('downloadChart').textContent = translations[lang].downloadChart;
      document.getElementById('exportStatsCsv').textContent = translations[lang].exportStatsCsv;
        
      // Labels mode et langue
      document.querySelector("#theme-switcher h1").textContent = translations[lang].modeLabel;
      document.querySelector("#language-switcher h1").textContent = translations[lang].languageLabel;

      // System info labels
      const systemLabels = document.querySelectorAll(".system-info p");

      if (systemLabels.length >= 4) {
        systemLabels[0].querySelector("strong").textContent = translations[lang].system.state + " :";
        systemLabels[1].querySelector("strong").textContent = translations[lang].system.total + " :";
        systemLabels[2].querySelector("strong").textContent = translations[lang].system.duration + " :";
        systemLabels[3].querySelector("strong").textContent = translations[lang].system.last + " :";
      }
      updateChart();  
      updateSystemState(systemActif ? "ON" : "OFF");
    }

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        sections.forEach(s => s.classList.remove('active'));
        document.getElementById(tab.dataset.target).classList.add('active');
      });
    });

    // Thème
    const lightThemeBtn = document.getElementById('lightThemeBtn');
    const darkThemeBtn = document.getElementById('darkThemeBtn');

    function applyTheme(theme) {
      if (theme === 'dark') {
        document.body.classList.add('dark-theme');
        darkThemeBtn.classList.add('active');
        lightThemeBtn.classList.remove('active');
      } else {
        document.body.classList.remove('dark-theme');
        lightThemeBtn.classList.add('active');
        darkThemeBtn.classList.remove('active');
      }
      localStorage.setItem('theme', theme);
    }

    lightThemeBtn.addEventListener('click', () => applyTheme('light'));
    darkThemeBtn.addEventListener('click', () => applyTheme('dark'));

    // Mise à jour état système
    function updateSystemState(state) {
      const lang = localStorage.getItem('lang') || 'fr';
      const isOn = state === "ON";

      systemActif = isOn;
      etatElem.textContent = isOn
        ? "🟢 " + (lang === "fr" ? "Actif" : "Active")
        : "🔴 " + (lang === "fr" ? "Inactif" : "Inactive");
      etatElem.style.color = isOn ? "#27ae60" : "#e74c3c";
    }


    // Affichage le taux de detection du backend
    function updateTaux(taux_) {
      document.getElementById('taux-detection').textContent = (taux_ ? taux_ : 0) + '%';
    }


    // Normalise couleurs backend (fr) vers frontend (en)
    function normalizeColor(color) {
      const map = {
        rouge: 'red',
        jaune: 'yellow',
        bleu: 'blue',
        vert: 'green',
        inconnu: 'unknown'
      };
      return map[color] || color;
    }

    // Met à jour compteurs et affichages depuis données serveur
    function updateCountsAndHistory(data) {
      // Remise à zéro compteurs locaux
      for (const c of Object.keys(counts)) {
        counts[c] = 0;
      }

      // Met à jour compteurs avec données normalisées
      for (const [colorFR, count] of Object.entries(data.compteurs)) {
        const colorEN = normalizeColor(colorFR);
        counts[colorEN] = count;
        if(countElems[colorEN]) countElems[colorEN].textContent = count;
      }

      totalCount = data.total || Object.values(counts).reduce((a,b) => a+b,0);
      totalElem.textContent = totalCount;

      if(data.dernier) {
        const dernierNorm = normalizeColor(data.dernier);
        dernierDechetElem.textContent = `${getTypeName(dernierNorm)}`;
      }

      // Mise à jour de l'historique local (prend les 20 derniers)
      if (Array.isArray(data.historique)) {
        history.length = 0; // vide
        // Normalise et ajoute
        data.historique.slice(-20).forEach(item => {
          history.push({
            time: item.time,
            type: normalizeColor(item.color || item.type),
            color: normalizeColor(item.color || item.type)
          });
        });
      }

      updateHistoryTable();
      updateChart();
    }

    // Récupère le nom traduit d’un type (couleur EN)
    function getTypeName(type) {
      const tubes = translations[currentLang].tubes;
      return tubes[type] || translations[currentLang].unknown;
    }

    // Animation convoyeur
    function conveyorAnimation(type) {
      detectedObjectElem.className = 'detected-object active';
      conveyorState.className = 'pattern moving';
      detectedObjectElem.style.backgroundColor = getTubeColor(type);
      setTimeout(() => {
        detectedObjectElem.className = 'detected-object';
        conveyorState.className = 'pattern';
        detectedObjectElem.style.backgroundColor = 'transparent';
      }, DELAI_ANIM);
    }

    // Couleurs tubes (frontend)
    function getTubeColor(type) {
      switch (type) {
        case 'red': return '#ff4c4c';
        case 'yellow': return '#fbc02d';
        case 'blue': return '#1976d2';
        case 'green': return '#388e3c';
        default: return '#999';  //unknown
      }
    }

    // Met à jour le tableau historique HTML
    function updateHistoryTable() {
      const tbody = document.getElementById('historyBody');
      tbody.innerHTML = '';
      history.slice().reverse().forEach(item => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${item.time}</td>
          <td>${getTypeName(item.type)}</td>
          <td><span style="display:inline-block;width:16px;height:16px;background-color:${getTubeColor(item.color)};border-radius:4px;"></span></td>
        `;
        tbody.appendChild(tr);
      });
    }


    // Export CSV historique
    document.getElementById('exportBtn').addEventListener('click', () => {
      let csv = 'Chronologie,Type,Couleur\n';
      history.forEach(item => {
        csv += `"${item.time}","${getTypeName(item.type)}","${item.color}"\n`;
      });
      downloadFile(csv, 'historique_tri.csv');
    });

    // Export CSV stats
    document.getElementById('exportStatsCsv').addEventListener('click', () => {
      let csv = 'Type,Quantité\n';
      for (const [type, count] of Object.entries(counts)) {
        csv += `"${getTypeName(type)}",${count}\n`;
      }
      downloadFile(csv, 'stats_tri.csv');
    });

    // Téléchargement CSV
    function downloadFile(content, filename) {
      const blob = new Blob([content], {type: 'text/csv;charset=utf-8;'});
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Chart.js
    let pieChart = null;

    function initChart() {
      const ctx = document.getElementById('pieChart').getContext('2d');

      const labels = [
        translations[currentLang].tubes.red,
        translations[currentLang].tubes.yellow,
        translations[currentLang].tubes.blue,
        translations[currentLang].tubes.green,
        translations[currentLang].tubes.unknown
      ];

      pieChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            label: translations[currentLang].system.total,
            data: [0, 0, 0, 0, 0],
            backgroundColor: ['#ff4c4c', '#fbc02d', '#1976d2', '#388e3c', '#746f6f4c'],
            borderColor: '#fff',
            borderWidth: 2,
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'bottom'
            },
            datalabels: {
              color: '#fff',
              font: {
                weight: 'bold'
              },
              formatter: (value, context) => {
                const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                if (total === 0 || value === 0) return '';
                const percentage = (value / total) * 100;
                return percentage.toFixed(1) + '%';
              }
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }


    function updateChart() {
      if (!pieChart) return;

      pieChart.data.datasets[0].data = [
        counts.red,
        counts.yellow,
        counts.blue,
        counts.green,
        counts.unknown
      ];

      pieChart.data.labels = [
        translations[currentLang].tubes.red,
        translations[currentLang].tubes.yellow,
        translations[currentLang].tubes.blue,
        translations[currentLang].tubes.green,
        translations[currentLang].tubes.unknown
      ];

      pieChart.data.datasets[0].label = translations[currentLang].system.total;

      pieChart.update();
    }

    // Télécharger graphique en PNG
    document.getElementById('downloadChart').addEventListener('click', () => {
      if (!pieChart) return;
      const link = document.createElement('a');
      link.download = 'graphique_tri.png';
      link.href = pieChart.toBase64Image();
      link.click();
    });

    // Boutons langues
    document.getElementById('frBtn').addEventListener('click', () => {
      switchLang('fr');
      setActiveLangBtn('fr');
    });
    document.getElementById('enBtn').addEventListener('click', () => {
      switchLang('en');
      setActiveLangBtn('en');
    });

    function setActiveLangBtn(lang) {
      document.getElementById('frBtn').classList.toggle('active', lang === 'fr');
      document.getElementById('enBtn').classList.toggle('active', lang === 'en');
    }

    // Réinitialisation compteurs (appel API /reset)
    document.getElementById('resetCountersBtn').addEventListener('click', () => {
      const code = prompt("Entrez le code secret (1234) pour réinitialiser :");
      if (!code) return;
      fetch('/reset', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ code_secret: code })
      }).then(res => {
        if (res.ok) {
          ancienTotal = 0;
          hasInitialized = true;
        } else {
          alert("Code secret incorrect !");
        }
      });
    });

    // Setup Socket.IO
    const socket = io();

    let ancienTotal = 0;

    function setupSocketIO() {
      socket.on('update_data', (data) => {
        updateSystemState(data.etat_systeme);
        updateTaux(data.taux);
        updateCountsAndHistory(data);

        const couleurNorm = normalizeColor(data.dernier);
        const nouveauTotal = data.total;

        if (hasInitialized) {
          if (couleurNorm && nouveauTotal > ancienTotal) {
            ancienTotal = nouveauTotal;
            conveyorAnimation(couleurNorm);
          }
        } else {
          // Première initialisation : pas d'animation
          ancienTotal = nouveauTotal;
          hasInitialized = true;
        }
      });
    }

    // Initialisation complète
    function init() {
      
      // Thème
      const savedTheme = localStorage.getItem('theme') || 'light';
      applyTheme(savedTheme);

      // Langue
      switchLang(currentLang);
      setActiveLangBtn(currentLang);

      // Onglets init (active premier)
      tabs[0].classList.add('active');
      sections.forEach((s, i) => s.classList.toggle('active', i === 0));

      // Chart
      initChart();

      // Socket
      setupSocketIO();
    }

    document.addEventListener('DOMContentLoaded', init);                    
                  </code></pre>
                </div>

                <h4>c. Tableau récapitulatif</h4>
                  <table border="2" cellspacing="1" cellpadding="6">
                    <thead>
                      <tr>
                        <th>Domaine</th>
                        <th>Langages / Outils</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><strong>Web Backend</strong></td>
                        <td>Flask, Python, SocketIO</td>
                      </tr>
                      <tr>
                        <td><strong>Web Frontend</strong></td>
                        <td>HTML, CSS, JS, Bootstrap 5, Chart.js</td>
                      </tr>
                      <tr>
                        <td><strong>Communication PC-Arduino</strong></td>
                        <td>USB, PySerial(port, 9600 bauds)</td>
                      </tr>
                    </tbody>
                  </table>
 
          <h3 id="4-info2">4. Communication série et Traitement des Données</h3>
            <p>
              La communication série entre l'Arduino et l'ordinateur (serveur Python) est essentielle. 
              Elle se fait par port USB en utilisant un port COM (ex: COM3).
            </p>
            
              <h4>a. Communication Arduino-PC-Interface</h4>
                <ul>
                  <li>
                    <strong>Arduino → PC</strong>: Envoie une donnée 
                    <ul>
                      <li>une caractère (R: red, G: green, B: blue, Y: yellow, U: unknown) chaque fois que la couleur de l'objet est identifiée.</li>
                      <li>une chaine de caractère (ON, OFF) à chaque mise en marche/arrêt du système de convoyeur.</li>
                    </ul>
                  </li>
                  <li>
                    <strong>PC (Python) → Web</strong>: Reçoit une donnée, l’interprète, met à jour les données(nombre de déchats, taux, ...), et l’envoie en temps réel à l’interface web via WebSocket.
                  </li>
                </ul>

              <h4>b. Détails techniques</h4>
                <ul>
                  <li>
                    <strong>Vitesse de transmission</strong>: 9600 bauds (via Serial.begin(9600)).
                  <li>
                    <strong>Traitement des données</strong> via le module pyserial en Python.
                  </li>
                  <li>
                    Le port série est ouvert(après selection de l'utilisateur) au démarrage du serveur <strong>Flask</strong>.
                  </li>
                </ul>
              <h4>c. Traitements des données</h4>
                <p>
                  Les données reçues de l’Arduino sont traitées en temps réel côté serveur comme suit:
                  <ul>
                    <li>Lecture de la donnée reçue ('R', 'G', etc.)</li>
                    <li>Mise à jour de l'ensemble du système(état, taux, nombre de déchets, ...)</li>
                    <li>Enregistrement des données(historique et statistiques)</li>
                    <li>Emission d'événement vers l'interface</li>
                  </ul>
                </p>

          <h3 id="5-info2">5. Instructions d'utilisation</h3>              
              <ul>
                Voici les étapes pour lancer et manipuler l'interface web:
                <li><strong>Lancement du serveur</strong></li>
                <p>
                  Lancer le serveur Flask via la commande <strong>python app.py</strong>. 
                </p>
                <li>
                  L'utilisateur selectionne le port auquel l'Arduino est connecté.
                </li>
                <li>
                  <strong>Accès à l’interface</strong>: 
                  Ouvrir un navigateur et aller à l’adresse IP indiquée dans la console.
                </li>
                <li>
                  <strong>Visualisation des données et navigation sur l'interface</strong>: 
                  l'utilisateur peut suivre le tri sur l'interface et naviguer pour les différentes options(historique et statistiques) disponibles.
                </li>      
                <li>
                  <strong>Paramètres</strong>: 
                  l'utilisateur peut modifier certaines paramètres de l'interfae(thème, langue, réinitialisation)
                </li>
              </ul>


            <div class="image-container">
              <img src="images/Test4_2/IT/web5.png" alt="web" class="image-mean"/>
              <img src="images/Test4_2/IT/web6.png" alt="web" class="image-mean"/>
            </div>

            <p class="txt_center">
              <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/raw/refs/heads/main/Test4_2/IT/convoyeur_web.zip" download class="download-link">télécharger les fichiers de l'interface web</a>
            </p>

        </div>

        <div id="validation2" class="subtab-content">
          <h2 id="test2" class="projet-titre">Tests et validation</h2>
          <h3 id="1-test2">1. Assemblage du convoyeur</h3>
            <p>
              Nous avons ici l'assemblage de la partie mécanique et de la partie électronqiue.
              Nous avons profité du temps supplémentaire pour améliorer notre convoyeur déjà fonctionnel et répondant au cahier de charge.
              Voici donc l'avant-après:
            </p>
            <div class="image-container">
              <p>
                <strong>Avant:</strong>
              </p>
              <img src="images/Test4_2/Convoyeur/realisation1_1.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation1_2.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation1_3.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation1_4.jpg" alt="realisation" class="image-small"/>
            </div>

             <video controls width=30%>
              <source src="videos/Test4_2/Convoyeur/convoyeur1.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>

            <div class="image-container">
              <p>
                <strong>Après:</strong>
              </p>
              <img src="images/Test4_2/Convoyeur/realisation2_1.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation2_2.jpg" alt="realisation" class="image-small"/>  
              <img src="images/Test4_2/Convoyeur/realisation2_3.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation2_4.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation2_5.jpg" alt="realisation" class="image-small"/>
              <img src="images/Test4_2/Convoyeur/realisation2_6.jpg" alt="realisation" class="image-small"/>
              <!-- <img src="images/Test4/Convoyeur/realisation2_7.jpg" alt="realisation" class="image-small"/> -->
            </div>

           

          <h3 id="2-test2">2. Protocole de test</h3>
            <p>
              Les tests individuels de chaque domaine ayant déjà été effectués, cette section est consacrée à l’évaluation du système global. 
              L’objectif est de vérifier l’intégration de tous les modules pour garantir le bon fonctionnement de l’ensemble. 
              Il s’agit donc de s’assurer que chaque domaine interagit correctement avec les autres dans un environnement complet et cohérent. 
            
              <ul>
                <p class="txt_center"><strong>Avant amélioration:</strong></p>
                <li>
                  Nous avons commencé par tester l'intégration de l'électronique et de la détection intelligente avec la structure du convoyeur à l'aide d'un petit code.
                </li>
                <video controls width=auto>
                  <source src="videos/Test4_2/Convoyeur/test2.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vidéo HTML5.
                </video>

                <li>
                  Puis, nous avons testé le système avec l'interface web.
                </li>
                <video controls width=auto>
                  <source src="videos/Test4_2/Convoyeur/test3.mp4" type="video/mp4">
                  Votre navigateur ne supporte pas la vidéo HTML5.
                </video>
              </ul>
              
            </p>

            <p class="txt_center">
              <strong>Après amélioration: </strong>(bientôt disponible)
            </p>

          <h3 id="3-test2">3. Résultats et démonstration</h3>
            <p>
              Après plusieurs tests et modifications, nous sommes parvenus à réaliser le système de convoyeur répondant au cahier de charge.
              En effet, le convoyeur respecte les <strong>contraintes de dimension</strong>(longueur et hauteur).
              Le tapis du convoyeur reste <strong>immobile</strong> et <strong>ne se meut que</strong> le système détecte des déchets.
              Ensuite, les déchets sont <strong>identifié</strong> lorsqu'ils passent dans la zone du capteur de couleur. 
              Ils  seront <strong>collectés manuellement</strong> à la fin du convoyeur et <strong>mis dans la berne</strong> indiquée par le système.
              Nous avons aussi mis en place une <strong>interface web</strong> pour permettre un suivi en temps réel du tri des déchets.
            </p>
            <p>
              Voici des images et videos montrant notre travail:
            </p>

            <p class="txt_center"><strong>Avant amélioration:</strong></p>
            <div class="image-container">
              <img src="images/Test4_2/Convoyeur/realisation8.jpg" alt="realisation" class="image-small"/>
            </div>

            <video controls width=auto>
              <source src="videos/Test4_2/Convoyeur/demo1.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>

            <p class="txt_center"><strong>Après amélioration:</strong>(bientôt disponible)</p>
            <div class="image-container">
              <img src="images/Test4_2/Convoyeur/realisation9.jpg" alt="realisation" class="image-small"/>
            </div>

            <video controls width=auto>
              <source src="videos/Test4_2/Convoyeur/demo2.mp4" type="video/mp4">
              Votre navigateur ne supporte pas la vidéo HTML5.
            </video>


        </div>

        <div id="conclusion2" class="subtab-content">
          <h2 id="concl2" class="projet-titre">Conclusion et Annexes</h2>
          <h3 id="1-concl2">1. Conclusion et perspectives</h3>
            <h4>Conclusion</h4>
            <p>
              Ce projet de convoyeur intelligent s’inscrit dans une dynamique de modernisation des processus industriels en intégrant des technologies issues de la mécanique, de l’électronique embarquée et de l’informatique. 
              À travers ce système, nous avons démontré la possibilité de concevoir un dispositif autonome capable de détecter, identifier, trier et comptabiliser des déchets selon leur couleur, 
              tout en assurant une visualisation en temps réel via une interface web conviviale.
            </p>
            <p>
              L’intégration réussie des différents modules (capteurs, motorisation, contrôle Arduino, communication série, interface web) confirme la faisabilité technique du système. 
              Les tests ont permis de valider le bon fonctionnement global, avec une réactivité satisfaisante, une précision correcte dans l’identification des couleurs et une visualisation instantanée des données.
            </p>
            <h4>Perspectives</h4>
              <p>
                Afin d’améliorer et de faire évoluer ce système, plusieurs pistes peuvent être envisagées :
                <ul>
                  <li>
                    Tri physique automatisé : 
                    Ajouter des actionneurs (comme des bras ou des trappes motorisées) 
                    pour permettre un tri automatique dans les bacs, sans intervention humaine.
                  </li>
                  <li>
                    Reconnaissance avancée : Intégrer des capteurs plus précis 
                    ou une caméra avec vision par ordinateur pour reconnaître non seulement la couleur, mais aussi la forme ou la matière du déchet.
                  </li>
                  <li>
                    Interface distante : Permettre un accès à distance à l’interface via le cloud, 
                    pour un suivi en temps réel depuis n’importe quel appareil connecté.
                  </li>
                </ul>
              </p>
              <p>
                Ce projet, en plus de sa portée pédagogique, constitue une base solide pour des applications concrètes dans le domaine du tri des déchets, 
                contribuant ainsi à une gestion plus durable des ressources.
              </p>
          <h3 id="2-concl2">2. Annexes</h3>
            <p>
              Fiches techniques des composants électroniques:
            </p>
              <ul>
                <li>
                  Microcontrôleur: 
                  <a href="https://docs.arduino.cc/resources/datasheets/A000005-datasheet.pdf" target="_blank">Arduino nano</a>
                </li>
                <li>
                  Capteur de couleur: 
                  <a href="https://www.mouser.com/catalog/specsheets/tcs3200-e11.pdf?srsltid=AfmBOoryK8wKLsTUaZK-DPXlDA7PPmU7zvHeu1G3dqKgPZAXs0rpiqxm" target="_blank">TCS230/TCS3200</a>
                </li>
                <li>
                  Capteur Ultrason: 
                  <a href="https://www.robot-maker.com/shop/img/cms/datasheet-capteur-ultrasons-hc-sr04.pdf" download target="_blank">HC-SR04</a>
                </li>
                <li>
                  Capteur infrarouge: 
                  <a href="https://www.vishay.com/docs/83760/tcrt5000.pdf" download target="_blank">TRCT5000</a>
                </li>
                <li>
                  Affichage visuelle: 
                  <a href="https://www.electronicoscaldas.com/datasheet/LED5D-RGB-CA.pdf?srsltid=AfmBOoqs7qaS3Igqh4KOchV5kW2dMOhyP29FHSZP3KxMu2uM1ZmHUj3s" download target="_blank">LED RGB</a>
                </li>
                <li>
                  Module Wi-Fi: 
                  <a href="https://academy.cba.mit.edu/classes/networking_communications/ESP8266/esp01.pdf" download target="_blank">ESP-01</a>
                </li>
                <li>
                  Module Buck: 
                  <a href="https://cdn-shop.adafruit.com/datasheets/MP2307_r1.9.pdf" download target="_blank">MP2307</a>
                </li>
              </ul>
        </div>

      </section>
    </main>
  </div>

  <footer>
    Copyright © 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script src="scripts/script_commun.js"></script>
  <script src="scripts/script_code.js"></script>
</body>
</html>
